@ROUT !
   @define pre @@(@pre)@
   @PRE S C
      @define typ @float@
      @define sz @4@
   @PRE D Z
      @define sz @8@
      @define typ @double@
   @PRE !
#define ATL_VLEN @(vl)
#if !defined(SREAL) && !defined(DREAL) && !defined(SCPLX) && !defined(DCPLX)
   @PRE C `   #define SCPLX 1`
   @PRE S `   #define SREAL 1`
   @PRE D `   #define DREAL 1`
   @PRE Z `   #define DCPLX 1`
#endif
@ifdef ! TRI
   @iexp TRI 0
@endifdef
@SKIP TRI = 1 means lower triangular C (SYRK)
@iif TRI = 1
   @define ma @1@
   @define na @1@
   @iif mu ! nu
      @iif mu > nu
         @iexp ma @(nu) @(mu) / 
         @iexp mma @(ma) @(nu) *
         @iif mu ! mma
           @abort "mu (@(mu)) must be mupliple of nu (@(nu))"  
         @endiif
         @skip @print ************ma = @(ma)
      @endiif
      @iif nu > mu
         @iexp na @(mu) @(nu) / 
         @iexp nna @(na) @(mu) *
         @iif nu ! nna
           @abort "nu (@(nu)) must be mupliple of mu (@(mu))"  
         @endiif
         @skip @print ************na = @(na)
      @endiif
      @define mEn @0@
   @endiif
   @iif mu = nu
      @define mEn @1@
   @endiif
@endiif
@SKIP TRMM=1,2,3,4; 1=Left Lower, 2=Left Upper, 3=Right Lower, 4=Right Upper
@ifdef ! TRMM
   @iexp TRMM 0
   @iexp TRMML 0
   @iexp TRMMR 0
@endifdef
@iif TRMM ! 0
   @iexp TRMML 3 @(TRMM) <
   @iexp TRMMR 2 @(TRMM) >
@endiif
@iif TRMML ! 0
   @iexp mku @(mu) @(ku) %
   @iexp kmu @(ku) @(mu) %
   @iif mku ! 0
      @iif kmu ! 0
         @abort "mu (@(mu)) must be multiple of or divisible by ku (@(ku))!"
      @endiif
   @endiif
   @ifdef PBINC
      @abort "PBINC cannot be defined!"
   @endifdef
   @define PBINC @0@
   @ifdef PBLHOIST
      @abort "PBLHOIST cannot be defined!"
   @endifdef
   @define PBLHOIST @0@
@endiif
@iif TRMMR ! 0
   @iexp nku @(nu) @(ku) %
   @iexp knu @(ku) @(nu) %
   @iif nku ! 0
      @iif knu ! 0
         @abort "nu (@(nu)) must be multiple of or divisible by ku (@(ku))!"
      @endiif
   @endiif
@endiif
@ROUT amm
@beginskip
Should be called with VEC=[NO,MDIM,KDIM], TYPE=[SREAL,DREAL] and 
following defines:
   mu : m (scalar) unrolling
   nu : n (scalar) unrolling
   ku : k (scalar) unrolling
   vl : vector length to use
The following can be optionally defined:
   kb : compile-time constant K loop bound to use
   kp : # of kits to peel, must be a multiple of vku!
   bc : don't define or set to 1 to use ATL_vbcast, 0 to use vld/vsplat
   pf : bit vec describing prefetch strategy
   pfLS : line size to assume for prefetch (64 bytes by default)
   bc : now used a bitvector, default 1, with following meanings:
    BPOS: SET MEANING
      0 : use bcast (else use splat) for B load (ignored for K-vec)
      1 : use only 1 register for B loads (ignored if using splat)
      2 : nnu=1 (else need N-loop)
      3 : nmu=1 (else need M-loop)

pf bit location meanings:
   prefC always done as just next mu*nu block
   pfA/B : can prefetch next mu/nu A/B within K-loop
   nA/nB : can prefetch next block outside K-loop 
   take pf integer bitvec bit/additive means:
      0/1   : prefetch C before K-loop
      1/2   : prefetch next block of A before K-loop
      2/4   : prefetch next block of B before K-loop
      3/8   : prefetch next mu*K iter of A inside K-loop
      4/16  : prefetch next nu*K iter of B inside K-loop
      5/32  : pref of C should use ATL_pfl1 instead of ATL_pfl2
      6/64  : pref of next blk of A should use ATL_pfl1 not ATL_pfl2
      7/128 : pref of next blk of B should use ATL_pfl1 not ATL_pfl2
      8/256 : pref of C should use ATL_pflX instead of ATL_pflX
      9/512 : pref of next blk of A should use ATL_pflX not ATL_pfl2
     10/1024: pref of next blk of B should use ATL_pflX not ATL_pfl2
     11/2048: K-loop pref of A use ATL_pfl1 not ATL_pfl2
     12/4096: K-loop pref of B use ATL_pfl1 not ATL_pfl2
     13/8192: K-loop pref of A use ATL_pflX not ATL_pfl2
    14/16384: K-loop pref of B use ATL_pflX not ATL_pfl2

   We'll put pf bitvec in rout name, and then the search will find that
   we want to pref everything to L1 for small NB, only C &  block of A for
   medium size, and no pref for large, for instance.

During tuning, think about several regions for prefetch:
1. pref pfnA&B to L1:  m*n + 2*k*(m+n) < L1
   -> n^2 + 4n^2 < L2 ==> nb <= sqrt(L1/5)
2. pref B to L1, A to L2: m*n + 2*k*n + m*k < L1
   -> n^2 + 2n^2 + n^2 < L1 ==> nb <= sqrt(L1/4)
3. pref A&B to L2 so long as all 5 blocks fit (L2 size not known)
4. pref only one of nA/B to L2
5. No prefetch of next blocks (maybe internal prefetch)
@endskip
@SKIP extract info from bc, then set it to bcast value
@ifdef ! bc
   @iexp bc 1
@endifdef
@skip if ((bc&1) == 0 && (bc&2) == 2) bc ^= 2
@iif @iexp @(bc) 1 & 0 = @(bc) 2 & 2 = &
   @iexp bc @(bc) 2 ^
@endiif
@iexp B1R @(bc) 2 & 0 !
@iexp DONLOOP @(bc) 4 & 0 =
@iexp DOMLOOP @(bc) 8 & 0 =
@iexp bc @(bc) 1 &
@print bc=@(bc) B1R=@(B1R) DO_N,M=@(DONLOOP),@(DONLOOP)
@SKIP KVEC & UNVEC can't use splat, so define bcast!
@VEC KDIM NO
@ifdef bc
   @undef bc
@endifdef
@iexp bc 0 1 +
@VEC MDIM
@ifdef ! bc
   @iexp bc 0 1 +
@endifdef
@VEC !
@ifdef ! pf
   @define pf @1@
@endifdef
@ifdef ! pfLS
   @define pfLS @64@
@endifdef
@iif pfLS = 0
   @define pfLS @64@
@endiif
@iexp pfLS @(sz) @(pfLS) /
@iexp kk @(pf) 32 &
@iif kk ! 0
   @define pfC @ATL_pfl1W@
@endiif
@iexp kk @(pf) 256 &
@iif kk ! 0
   @define pfC @ATL_pflXW@
@endiif
@ifdef ! pfC
   @define pfC @ATL_pfl2W@
@endifdef
@iexp kk @(pf) 64 &
@iif kk ! 0
   @define pfA @ATL_pfl1R@
@endiif
@iexp kk @(pf) 512 &
@iif kk ! 0
   @define pfA @ATL_pflXR@
@endiif
@ifdef ! pfA
   @define pfA @ATL_pfl2R@
@endifdef
@iexp kk @(pf) 128 &
@iif kk ! 0
   @define pfB @ATL_pfl1R@
@endiif
@iexp kk @(pf) 1024 &
@iif kk ! 0
   @define pfB @ATL_pflXR@
@endiif
@ifdef ! pfB
   @define pfB @ATL_pfl2R@
@endifdef
@iexp kk @(pf) 8 &
@iif kk ! 0
   @define pfAk @ATL_pfl2R@
   @iexp kk @(pf) 2048 &
   @iif kk ! 0
      @undef pfAk
      @define pfAk @ATL_pfl1R@
   @endiif
   @iexp kk @(pf) 8192 &
   @iif kk ! 0
      @undef pfAk
      @define pfAk @ATL_pflXR@
   @endiif
@endiif
@iexp kk @(pf) 16 &
@iif kk ! 0
   @define pfBk @ATL_pfl2R@
   @iexp kk @(pf) 4096 &
   @iif kk ! 0
      @undef pfBk
      @define pfBk @ATL_pfl1R@
   @endiif
   @iexp kk @(pf) 16384 &
   @iif kk ! 0
      @undef pfBk
      @define pfBk @ATL_pflXR@
   @endiif
@endiif
@SKIP npfC = (pf&1) * ((mu*nu + pfLS -1) / pfLS)
@iexp npfC 1 @(pf) & @(pfLS) @(nu) @(mu) * @(pfLS) + -1 + / *
@iexp npfA @(pfLS) 1 @(pf) r 1 & @(mu) @(nu) * * /
@iexp npfB @(pfLS) 2 @(pf) r 1 & @(mu) @(nu) * * /
@iexp npf @(npfC) @(npfA) +
@iif npfA ! 0
   @iexp npfA @(npfA) @(npfC) +
@endiif
@iif npfB ! 0
   @iexp npf @(npf) @(npfB) +
   @iexp npfB @(npf) 0 +
@endiif
@skip bc = (bc != 0 || (vl < 2) || nu%vl != 0);
@iexp bc 0 @(bc) ! 2 @(vl) < | @(vl) @(nu) % 0 ! |
@iif TRI = 1
   @VEC KDIM
      @iif ku ! vl
         @abort "ku (@(ku)) must equal vlen (@(vl))!"
      @endiif
   @VEC JJJJJ
      @iif ku ! 1
         @abort "ku must be 1, but it is @(ku)!"
      @endiif
   @VEC !
@endiif
#ifndef TYPE
   #define TYPE @(typ)
#endif
#include "atlas_simd.h"
@iexp pf @(pf) 31 &
@iif pf ! 0
#include "atlas_prefetch.h"
@endiif
@ifdef ! vl
   @abort "vl must be defined!"
@endifdef
@ifdef ! mu
   @abort "mu must be defined!"
@endifdef
@ifdef ! nu
   @abort "nu must be defined!"
@endifdef
@ifdef ! ku
   @abort "ku must be defined!"
@endifdef
@ifdef ! kb
   @define kb @0@
@endifdef
@iif kb = 0
   @addkeys KCON=no
@endiif
@iif kb ! 0
   @addkeys KCON=yes
@endiif
@iexp vku @(ku) 0 +
@iexp vmu @(mu) 0 +
@iexp vnu @(nu) 0 +
@VEC MDIM
   @iexp vmu @(vl) @(mu) /
   @iexp kk @(vmu) @(vl) *
   @iif kk ! mu
      @abort "MU=@(mu) illegal with VLEN=@(vl)!"
   @endiif
@VEC KDIM
   @iexp vku @(vl) @(ku) /
   @iif @iexp @(vku) @(vl) * @(ku) !
      @abort "KU=@(ku) illegal with VLEN=@(vl)!"
   @endiif
@VEC NO
   @iif vl ! 1
      @abort "vl must be 1 for scalar code!"
   @endiif
@VEC !
@ifdef ! kp
   @VEC KDIM `@define kp @@(vl)@`
   @VEC ! KDIM `@define kp @1@`
@endifdef
@VEC KDIM 
   @iexp vkp @(vl) @(kp) /
   @iexp kk @(vkp) @(vl) *
   @iif kk != ku
      @abort "KP (@(kp)) must be a multiple of ku*VLEN (@(ku)*@(vl))"
   @endiif
@VEC ! KDIM
   @define vkp @@(kp)@
@VEC !
@define KB @K@
@ifdef ! kp
   @VEC KDIM
      @define kp @@(vl)@
   @VEC ! KDIM
      @define kp @@(vku)@
   @VEC !
@endifdef
@iif vkp < 1
   @abort "K-peel (kp) must be >= 1!"
@endiif
@iexp kk @(ku) @(kp) /
@iexp kk @(kk) @(ku) *
@iif kp ! kk
   @abort "K-peel (@(kp)) must be a multiple of KU=@(ku)!"
@endiif
@VEC KDIM
@SKIP FOR KVEC, kb = CEIL(kb/vlen)*vlen
@iif kb ! 0
   @iexp kb @(vl) @(kb) @(vl) -1 + + / @(vl) *
   @undef KB
   @define KB @@(kb)@
   @iif @iexp @(vku) @(kb) %
      @abort "VKU=@(vku) must be multiple of @(kb)!"
   @endiif
@endiif
@VEC !
@iif kb > 0
#define ATL_KBCONST 1
#ifndef ATL_MM_KB
   #ifdef KB
      #define ATL_MM_KB KB
   #else
      #define ATL_MM_KB @(kb)
   #endif
#endif
@endiif
@iif kb = 0
#ifndef ATL_MM_KB 
   #ifdef KB
      #if KB > 0
         #define ATL_KBCONST 1
         #define ATL_MM_KB KB
      #else
         #define ATL_KBCONST 0
         #define ATL_MM_KB K
      #endif
   #else
      #define ATL_KBCONST 0
      #define ATL_MM_KB K
   #endif
#else
   #if ATL_MM_KB > 0
      #define ATL_KBCONST 1
   #else
      #undef ATL_MM_KB
      #define ATL_MM_KB K
      #define ATL_KBCONST 0
   #endif
#endif
@endiif
@SKIP special pB inc at the last K iteration
@iif TRMML ! 0
@BEGINPROC lKpBinc
   @iif PBLHOIST ! 0
      @ifdef LAST_ITER
   pB += incBn;
         @undef LAST_ITER 
      @endifdef
   @endiif
@ENDPROC
@endiif 
@VEC ! NO
#ifdef BETA1
   #define ATL_vbeta(p_, d_) \
   { \
      ATL_vld(rA0, p_); \
      ATL_vadd(d_, d_, rA0); \
      ATL_vst(p_, d_); \
   }
#elif defined(BETA0)
   #define ATL_vbeta(p_, d_) ATL_vst(p_, d_)
#else
   #define ATL_vbeta(p_, d_) \
   { \
      ATL_vld(rA0, p_); \
      ATL_vsub(d_, d_, rA0); \
      ATL_vst(p_, d_); \
   }
#endif
@VEC MDIM
   @iif bc = 0
      @BEGINPROC ldB spc d i_
      @beginindent 1 @(spc)
      @define j @@
      @define kk @@
@BEGINSKIP
         1-D must be able to do 2 memops/MAC to get peak, and a 2x2 2-D block
         must do a load for every MAC, so there will never be any "holes" to
         do extra memory operations like prefetch or advanced load for these
         cases.  1-D handles this with special code; to create a hole for 2x2
         we therefore don't count the last B load as memory load.  We do:
            IF (vmu != 2 || nu != 2 || i_ == nu-1)
               mo++  /* mo is count of memory ops done with last MAC */
         but this the same as
            mo = mo + 1*(vmu != 2 || nu != 2 || i_ == nu-1)
         which was obvious to you from the line below, of course.
@ENDSKIP
         @iexp mo 2 @(vmu) ! 2 @(nu) ! | @(i_) 1 @(nu) - = 1 * @(mo) +
         @iexp j @(vl) @(i_) /
         @iexp i_ @(vl) @(j) * @(i_) -
   ATL_vsplat@(i_)(@(d), vB@(j));
@SKIP    if ((i_+1)%vl == 0, add another vector to stack of vBs to load (lb)
         @iexp kk @(vl) 1 @(i_) + %
         @iif kk = 0
@SKIP    Keep macro stack in old->new order by reversing if non-empty
@SKIP    so we can add newest to bottom.
            @whiledef lb
               @define lb2 @@(lb)@
            @endwhile
            @define lb @@(j)@
            @whiledef lb2
               @define lb @@(lb2)@
            @endwhile
         @endiif
         @undef j
         @undef kk
      @endindent
      @ENDPROC
   @endiif
   @iif bc ! 0
      @BEGINPROC ldB spc d i_
      @beginindent 1 @(spc)
         @iexp mo 2 @(vmu) ! 2 @(nu) ! | @(i_) 1 @(nu) - = 1 * @(mo) +
         @iif ib < 0
            @iif i_ ! 0
   ATL_vbcast(@(d), pB+@(i_));
            @endiif
            @iif i_ = 0
            @SKIP *************************************************************
               @iif TRMML ! 0
                  @callproc lKpBinc
               @endiif
            @SKIP *************************************************************
   ATL_vbcast(@(d), pB);
            @endiif
         @endiif
         @iif ib > -1
            @iif ib ! 0
   ATL_vbcast(@(d), pB+@(ib));
             @endiif
            @iif ib = 0
            @SKIP *************************************************************
               @iif TRMML ! 0
                  @callproc lKpBinc
               @endiif
            @SKIP *************************************************************
   ATL_vbcast(@(d), pB);
             @endiif
            @iexp ib @(ib) 1 +
         @endiif
      @endindent
      @ENDPROC
   @endiif
@VEC KDIM
@BEGINSKIP
ARGS:
   nv : vvrsum # to use
   nr : actual number of registers remaining to be summed
   ir : base register number (0 <= ir < mu*nu)
ASSUMES: mu, nu, exreg
@ENDSKIP
   @BEGINPROC vvrsum nv nr ir
      @define k @0@
      @define kl @0@
      @define i @0@
      @define j @0@
      @declare "   ATL_vvrsum@(nv)(" y n ");"
         @iexp kl @(ir) @(nr) +
         @iexp k @(ir)
         @iwhile k < kl
            @iexp j @(mu) @(k) /
            @iexp i @(mu) @(k) %
               rC@(i)_@(j)
            @iexp k @(k) 1 +
         @endiwhile
         @iif nr < nv
            @iexp kl @(ir) @(nv) +
            @iwhile k < kl
               @(exreg)
            @iexp k @(k) 1 +
         @endiwhile
         @endiif
      @enddeclare
      @iexp j @(mu) @(ir) /
      @iexp i @(mu) @(ir) %
      @iexp kl @(j) @(mu) *
      @iexp kl @(kl) @(i) +
   ATL_vbeta(pC+@(kl), rC@(i)_@(j));
      @undef j
      @undef i
      @undef kl
      @undef k
   @ENDPROC
@VEC KDIM NO
   @BEGINPROC ldB spc d i_
   @beginindent 1 @(spc)
      @iexp i_ @(vl) @(i_) *
      @iexp mo 2 @(vmu) ! 2 @(nu) ! | @(i_) 1 @(nu) - = 1 * @(mo) +
      @iif ib < 0
         @iif i_ ! 0
   ATL_vld(@(d), pB+@(i_));
         @endiif
         @iif i_ = 0
         @SKIP *************************************************************
            @iif TRMML ! 0
               @callproc lKpBinc
            @endiif
         @SKIP *************************************************************
   ATL_vld(@(d), pB);
         @endiif
      @endiif
      @iif ib > -1 
         @iif ib ! 0
   ATL_vld(@(d), pB+@(ib));
         @endiif
         @iif ib = 0
         @SKIP *************************************************************
            @iif TRMML ! 0
               @callproc lKpBinc
            @endiif
         @SKIP *************************************************************
   ATL_vld(@(d), pB);
         @endiif
         @iexp ib @(ib) @(vl) +
      @endiif
   @endindent
   @ENDPROC
@VEC NO KDIM
   @define ldB @ATL_vld@
   @iexp bmul @(vl) 0 +
@VEC MDIM
   @define ldB @ATL_vbcast@
   @iexp bmul 1 0 +
@VEC NO
   @BEGINPROC storeC spc
   @define kk @dum@
   @define i @dum@
   @define j @dum@
   @beginindent 1 @(spc)
      @iexp kk 0 0 +
      @iexp j 0 0 +
      @iwhile j < @(nu)
         @iexp i 0 0 +
         @iwhile i < @(vmu)
   #ifdef BETA0
      pC[@(kk)] = rC@(i)_@(j);
   #elif defined(BETA1)
      pC[@(kk)] += rC@(i)_@(j);
   #else
      pC[@(kk)] = rC@(i)_@(j) - pC[@(kk)];
   #endif
            @iexp kk @(kk) 1 +
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
   @endindent
   @undef j
   @undef i
   @undef kk
   @ENDPROC
@VEC MDIM
   @BEGINPROC storeC spc
   @define kk @dum@
   @define i @dum@
   @define j @dum@
   @beginindent 1 @(spc)
      @iexp kk 0 0 +
      @iexp j 0 0 +
      @iwhile j < @(nu)
         @iexp i 0 0 +
         @iwhile i < @(vmu)
   ATL_vbeta(pC+@(kk), rC@(i)_@(j));
            @iexp kk @(kk) @(vl) +
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
   @endindent
   @undef kk
   @undef j
   @undef i
   @ENDPROC
@VEC KDIM
   @BEGINPROC storeC spc
      @define nr @dum@
      @define nf @dum@
      @define k @dum@
      @define ll @dum@
      @define vl2 @dum@

      @beginindent 1 @(spc)
         @iexp nf @(vl) @(mu) @(nu) * / @(vl) *
         @iexp nr @(nf) @(mu) @(nu) * -
         @iexp k 0
         @iwhile k < nf
            @callproc vvrsum @(vl) @(vl) @(k)
            @iexp k @(k) @(vl) +
         @endiwhile
         @iif nr = 1
            @callproc vvrsum 1 1 @(k)
         @endiif
         @iif nr > 1
            @iexp ll @(vl)
            @iwhile nr > 0
               @iexp vl2 2 @(ll) /
            @print nr=@(nr) ll=@(ll) vl2=@(vl2)
               @iif nr > vl2
                  @callproc vvrsum @(ll) @(nr) @(k)
                  @iexp nr 0
               @endiif
               @iif nr } vl2
                  @callproc vvrsum @(vl2) @(vl2) @(k)
                  @iexp nr @(vl2) @(nr) -
                  @iexp k @(k) @(vl2) +
               @endiif
               @iexp ll @(vl2)
            @endiwhile
         @endiif
      @endindent
      @undef k
      @undef nf
      @undef nr
      @undef ll
      @undef vl2
   @ENDPROC
@VEC KDIM
   @iexp incAk @(mu) @(vl) *
   @iexp incBk @(nu) @(vl) *
@VEC MDIM NO
   @iexp incAk @(mu)
   @iexp incBk @(nu)
@VEC !
@iexp TWOD 1 0 +
@iif vmu = 1
   @iexp TWOD 0 0 +
@endiif
@iif vnu = 1
   @iexp TWOD 0 0 +
@endiif
@skip NOKLOOP = (kb == ku);
@iexp NOKLOOP @(kb) @(ku) =
@iif NOKLOOP = 0
   @iexp ia -1 0 +
   @iexp ib -1 0 +
@endiif
@iif NOKLOOP ! 0
   @iexp ia 0 0 +
   @iexp ib 0 0 +
@endiif
@ifdef lb
   @abort "lb cannot be defined!"
@endifdef
@ifdef lb2
   @abort "lb2 cannot be defined!"
@endifdef

#ifndef ATL_CSZT
   #include <stddef.h>
   #define ATL_CSZT const size_t
#endif
@skip Helper func for DoIter[0].  
@skip IN: pfLS,npfA,npfB, npfC, ipb, ipa, mu, nu, IN_K; 
@skip IN/OUT: mo, ipf
@BEGINPROC DoPref
   @define kk @dum@
   @define jj @dum@
   @SKIP commented out, now handled in ldB
   @BEGINSKIP
   @SKIP if (vmu == 2 && vnu == 2 && mo = 1) mo = 0
   @iexp kk @(vmu) 2 = @(vnu) 2 = @(mo) 1 = & &
   @iif kk ! 0
      @iexp mo 0 0 +
   @endiif
   @ENDSKIP
   @iif mo = 0
      @iif ipf < npfC
         @iexp kk @(ipf) @(pfLS) *
               @(pfC)(pC+@(kk));
         @iexp ipf @(ipf) 1 +
         @iexp mo @(mo) 1 +
      @endiif
      @skip if (mo = 0 && ipf < npfA)
      @iexp kk @(mo) 0 = @(npfA) @(ipf) < &
      @iif kk ! 0
         @iexp kk @(npfC) @(ipf) - @(pfLS) *
               @(pfA)(pAn+@(kk));
         @iexp ipf @(ipf) 1 +
         @iif ipf = npfA
               pAn += incAN;
         @endiif
         @iexp mo @(mo) 1 +
      @endiif
      @skip if (mo == 0 && ipf < npfB)
      @iexp kk @(mo) 0 = @(npfB) @(ipf) < &
      @iif kk ! 0
         @iexp kk @(npfA) @(ipf) - @(pfLS) *
               @(pfB)(pBn+@(kk));
         @iexp ipf @(ipf) 1 +
         @iif ipf = npfB
               pBn += incBN;
         @endiif
         @iexp mo @(mo) 1 +
      @endiif
@SKIP Handle prefetch of next k loop traversal, if it exists
      @iif mo = 0
         @ifdef pfBk
            @SKIP if (NOKLOOP == 0 && IN_K != 0)
            @iexp kk 0 @(NOKLOOP) = 0 @(IN_K) ! &
            @iif kk ! 0
               @(pfBk)(pB+incBn);
                  @undef pfBk
               @iexp mo @(mo) 1 +
            @endiif
            @iexp jj @(kb) @(nu) *
            @SKIP if (NOKLOOP != 0 && ipb%pfLS == 0 && ipb < incBn)
            @iexp kk @(pfLS) @(ipb) % 0 = @(NOKLOOP) 0 ! & @(jj) @(ipb) < &
            @iif kk ! 0
               @iexp jj @(jj) @(ipb) +
            @(pfBk)(pB+@(jj));
               @iexp ipb @(ipb) @(pfLS) +
               @iexp mo @(mo) 1 +
            @iexp kk @(jj) @(ipb) <
            @endiif
         @endifdef
      @endiif
      @iif mo = 0
         @ifdef pfAk
            @SKIP if (NOKLOOP == 0 && IN_K != 0)
            @iexp kk 0 @(NOKLOOP) = 0 @(IN_K) ! &
            @iif kk ! 0
               @(pfAk)(pA+incAm);
                  @undef pfAk
               @iexp mo @(mo) 1 +
            @endiif
            @iexp jj @(kb) @(mu) *
            @SKIP if (NOKLOOP != 0 && ipa%pfLS == 0 && ipa < incAm)
            @iexp kk @(pfLS) @(ipa) % 0 = @(NOKLOOP) 0 ! & @(jj) @(ipa) < &
            @iif kk ! 0
               @iexp jj @(jj) @(ipa) +
            @(pfAk)(pA+@(jj));
               @iexp ipa @(ipa) @(pfLS) +
               @iexp mo @(mo) 1 +
            @endiif
         @endifdef
      @endiif
      @iif IN_K ! 0
         @ifdef pfAk
            @iif mo = 0
            @(pfAk)(pA+incAm);
               @undef pfAk
               @iexp mo @(mo) 1 +
            @endiif
         @endifdef
      @endiif
   @endiif
   @undef jj
   @undef kk
@ENDPROC
@beginskip
Perform initial iteration use vmul.  1-D scheduled to make it obvious
the non-unit dimension can be directly loaded from memory, rather than
really using registers.  This allows total number of registers to be:
   MAX(MU,NU) + 1
ASSUMES DEFINED: ldB, incBk, bmul, incAk, vmu, vnu, vl
@endskip
@BEGINPROC DoIter0_k
@SKIP define internal vars, so they can popped off to leave caller unchanged
   @define DN @0@
   @define i @0@
   @define j @0@
   @define kk @0@
@SKIP 1-D with NU=1
   @iif vnu = 1
      @iexp DN 1 0 +
         @callproc ldB 9 rB0 0
         @iexp i 0 0 +
         @iwhile i < @(vmu)
         ATL_vld(rC@(i)_0, pA+@(ia));
            @iexp ia @(ia) @(vl) +
         ATL_vmul(rC@(i)_0, rC@(i)_0, rB0);
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
   @endiif
@SKIP 1-D with VMU=1
   @iif DN = 0
      @iif vmu = 1
         @iexp DN 1 0 +
         ATL_vld(rA0, pA+@(ia));
         @iexp ia @(ia) @(vl) +
@skip         @iexp ia @(ia) @(incAk) +
         @iexp j 0 0 +
         @iwhile j < @(vnu)
            @callproc ldB 6 rC0_@(j) @(j)
         ATL_vmul(rC0_@(j), rC0_@(j), rA0);
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp j @(j) 1 +
            @skip if (bc==0 && j%vl==0)
            @iexp kk @(bc) 0 = @(vl) @(j) % 0 = &
            @ifdef lb
             ATL_vld(vB@(lb), pB+@(ib));
                @undef lb
                @iexp ib @(ib) @(vl) +
            @endifdef
         @endiwhile
      @endiif
   @endiif
@SKIP 2-D case assumes all but last rB already loaded unless B1R is set
   @iif DN = 0
      @define jb @0@
         ATL_vld(rA0, pA);
      @iexp ia @(ia) @(vl) +
      @iexp i 0 1 +
      @iwhile i < @(vmu)
         ATL_vld(rA@(i), pA+@(ia));
         @iexp ia @(ia) @(vl) +
         @iexp i @(i) 1 +
      @endiwhile
      @iif B1R = 0
         @callproc ldB 6 rB@(jl) @(jl)
      @endiif
      @ifdef lb
         ATL_vld(vB@(lb), pB+@(ib));  /* A01 */
         @undef lb
         @iexp ib @(ib) @(vl) +
      @endifdef
      @iexp j 0 0 +
      @iwhile j < @(vnu)
         @iexp jb 0 @(B1R) = @(j) *
         @iif B1R ! 0
            @callproc ldB 9 rB0 @(j)
         @endiif
         @iexp i 0 0 +
         @iwhile i < @(vmu)
         ATL_vmul(rC@(i)_@(j), rA@(i), rB@(jb));
            @iexp mo 0 0 +
            @iif j = jl
            ATL_vld(rA@(i), pA+@(ia));
               @iexp ia @(ia) @(vl) +
               @iexp mo @(mo) 1 +
            @endiif
            @iif mo = 0
               @ifdef lb
            ATL_vld(vB@(lb), pB+@(ib));  /* A02 i=@(i) j=@(j) */
                  @undef lb
                  @iexp mo @(mo) 1 +
                  @iexp ib @(ib) @(vl) +
               @endifdef
            @endiif
            @skip if (i == il && j != jl && !B1R)
            @iif @iexp @(i) @(il) = @(j) @(jl) ! & @(B1R) 0 = &
               @callproc ldB 9 rB@(j) @(j)
            @endiif
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
      @undef jb
   @endiif
@SKIP pop our defs so caller's macros of same name aren't changed
   @undef DN
   @undef i
   @undef j
   @undef kk
@ENDPROC
@SKIP Do normal iteration
@SKIP ASSUMES DEFINED: ldB, incBk, bmul, incAk, vmu, vnu, vl, jpf
@BEGINPROC DoIter_k
@SKIP define internal vars, so they can popped off to leave caller unchanged
   @define DN @0@
   @define i @0@
   @define j @0@
   @define kk @0@
@SKIP 1-D with NU=1
   @iif vnu = 1
      @iexp DN 1 0 +
         @callproc ldB 9 rB0 0
         @iexp i 0 0 +
         @iwhile i < @(vmu)
            ATL_vld(rA0, pA+@(ia));
            @iexp ia @(ia) @(vl) +
            ATL_vmac(rC@(i)_0, rA0, rB0);
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
   @endiif
@SKIP 1-D with MU=1
   @iif DN = 0
      @iif vmu = 1
         @iexp DN 1 0 +
            ATL_vld(rA0, pA+@(ia));
            @iexp ia @(ia) @(vl) +
         @iexp j 0 0 +
         @iwhile j < @(vnu)
            @callproc ldB 9 rB0 @(j)
            ATL_vmac(rC0_@(j), rA0, rB0);
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp j @(j) 1 +
            @skip if (bc==0 && j%vl==0)
            @iexp kk @(bc) 0 = @(vl) @(j) % 0 = &
            @iif kk ! 0
               @iexp kk @(vl) @(j) / -1 +
             ATL_vld(vB@(kk), pB+@(ib)); /* 01 */
               @iexp ib @(ib) @(vl) +
            @endiif
         @endiwhile
      @endiif
   @endiif
@SKIP 2-D case assumes all but last rB already loaded unless B1R true
   @iif DN = 0
      @define jb @0@
      @iexp j 0 0 +
      @iwhile j < @(vnu)
         @iexp jb 0 @(B1R) = @(j) *
         @iif B1R ! 0
            @callproc ldB 12 rB0 @(jl)
         @endiif
         @iexp i 0 0 +
         @iwhile i < @(vmu)
            @iexp mo 0 0 +
            ATL_vmac(rC@(i)_@(j), rA@(i), rB@(jb));
            @skip if ((i|j) == 0 && !B1R)
            @iif @iexp @(i) @(j) | 0 = @(B1R) 0 = &
               @iexp kk @(jl) @(bmul) *
               @callproc ldB 12 rB@(jl) @(jl)
                  @ifdef lb
               ATL_vld(vB@(lb), pB+@(ib)); /* 02 */
                     @undef lb
                     @iexp ib @(ib) @(vl) +
                     @iexp mo 1 0 +
                  @endifdef
            @endiif
            @iif j = jl
               ATL_vld(rA@(i), pA+@(ia));
               @iexp ia @(ia) @(vl) +
               @iexp mo 1 0 +
            @endiif
            @skip if (j != jl && i == il && !B1R
            @iif @iexp @(j) @(jl) ! @(i) @(il) = & @(B1R) 0 = &
               @callproc ldB 12 rB@(j) @(j)
            @endiif
            @iif mo = 0
               @ifdef lb
               ATL_vld(vB@(lb), pB+@(ib)); /* 03 */
                  @undef lb
                  @iexp ib @(ib) @(vl) +
                  @SKIP if (vmu !=2 && vnu != 2) mo++
                  @iexp kk @(vmu) 2 ! @(vnu) 2 ! |
                  @iif kk ! 0
                     @iexp mo 1 0 +
                  @endiif
               @endifdef
            @endiif
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
      @undef jb
   @endiif
@SKIP pop our defs so caller's macros of same name aren't changed
   @undef DN
   @undef i
   @undef j
   @undef kk
@ENDPROC
@BEGINPROC DoIter0
@SKIP define internal vars, so they can popped off to leave caller unchanged
   @define DN @0@
   @define i @0@
   @define j @0@
   @define kk @0@
@SKIP 1-D with NU=1
   @iif vnu = 1
      @iexp DN 1 0 +
         @(ldB)(rB0, pB);
         pB += @(incBk);
         @iexp i 0 0 +
         @iwhile i < @(vmu)
            @iexp kk @(i) @(vl) *
         ATL_vld(rC@(i)_0, pA+@(kk));
         ATL_vmul(rC@(i)_0, rC@(i)_0, rB0);
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
         pA += @(incAk);
   @endiif
@SKIP 1-D with VMU=1
   @iif DN = 0
      @iif vmu = 1
         @iexp DN 1 0 +
         ATL_vld(rA0, pA);
         pA += @(incAk);
         @iexp j 0 0 +
         @iwhile j < @(vnu)
            @callproc ldB 6 rC0_@(j) @(j)
         ATL_vmul(rC0_@(j), rC0_@(j), rA0);
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp j @(j) 1 +
            @skip if (bc==0 && j%vl==0)
            @iexp kk @(bc) 0 = @(vl) @(j) % 0 = &
            @iif kk ! 0
               @iexp kk @(vl) @(j) / -1 +
               @iexp jj @(kk) @(vl) *
             ATL_vld(vB@(kk), pB+@(jj));
            @endiif
         @endiwhile
         pB += @(incBk);
      @endiif
   @endiif
@SKIP 2-D case assumes all but last rB already loaded unless B1R is true
   @iif DN = 0
      @define jb @0@
         ATL_vld(rA0, pA);
      @iexp i 0 1 +
      @iwhile i < @(vmu)
         @iexp kk @(i) @(vl) *
         ATL_vld(rA@(i), pA+@(kk));
         @iexp i @(i) 1 +
      @endiwhile
      @iif B1R = 0
         @callproc ldB 6 rB@(jl) @(jl)
      @endiif
         pA += @(incAk);
      @ifdef lb
         @iexp jj @(vl) @(lb) *
         ATL_vld(vB@(lb), pB+@(jj)); /* di0_00 */
         @undef lb
      @endifdef
      @iif B1R = 0
         pB += @(incBk);
      @endiif
      @iexp j 0 0 +
      @iwhile j < @(vnu)
         @iif B1R ! 0
            @callproc ldB 6 rB0 @(j)
            @iif @iexp @(vnu) -1 + @(j) =
               pB += @(incBk); /* di0_02 */
            @endiif
         @endiif
         @iexp jb 0 @(B1R) = @(j) *
         @iexp i 0 0 +
         @iwhile i < @(vmu)
         ATL_vmul(rC@(i)_@(j), rA@(i), rB@(jb));
            @iexp mo 0 0 +
            @iif j = jl
               @iexp kk @(i) @(vl) *
            ATL_vld(rA@(i), pA+@(kk));
               @iexp mo @(mo) 1 +
                  @iif i = il
            pA += @(incAk);
                  @endiif
            @endiif
            @iif mo = 0
               @ifdef lb
                  @iexp kk @(lb) @(vl) *
               ATL_vld(vB@(lb), pB+@(kk)); /* di0_01: lb=@(lb) jl=@(jl) */
                  @iexp kk @(kk) @(vl) +
                  @iif kk = incBk
               pB += @(incBk); /* di0_02 */
                  @endiif
                  @undef lb
                  @iexp mo @(mo) 1 +
               @endifdef
            @endiif
            @iif B1R = 0
               @iif i = il
                  @iif j ! jl
                     @iexp kk @(j) @(bmul) *
            @callproc ldB 9 rB@(j) @(j)
                  @endiif
               @endiif
            @endiif
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
      @undef jb
   @endiif
@SKIP pop our defs so caller's macros of same name aren't changed
   @undef DN
   @undef i
   @undef j
   @undef kk
@ENDPROC
@SKIP Do normal iteration
@SKIP ASSUMES DEFINED: ldB, incBk, bmul, incAk, vmu, vnu, vl, jpf
@BEGINPROC DoIter
@SKIP define internal vars, so they can popped off to leave caller unchanged
   @define DN @0@
   @define i @0@
   @define j @0@
   @define kk @0@
@SKIP 1-D with NU=1
   @iif vnu = 1
      @iexp DN 1 0 +
         @SKIP *************** LAST_ITER: increment pB before 1st pB Loading 
         @iif TRMML ! 0
            @callproc lKpBinc
         @endiif
         @SKIP **********************************************************
            @(ldB)(rB0, pB);
            pB += @(incBk);
         @iexp i 0 0 +
         @iwhile i < @(vmu)
            @iexp kk @(i) @(vl) *
            ATL_vld(rA0, pA+@(kk));
            ATL_vmac(rC@(i)_0, rA0, rB0);
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
            pA += @(incAk);
   @endiif
@SKIP 1-D with MU=1
   @iif DN = 0
      @iif vmu = 1
         @iexp DN 1 0 +
            ATL_vld(rA0, pA);
            pA += @(incAk);
         @iexp j 0 0 +
         @iwhile j < @(vnu)
            @callproc ldB 9 rB0 @(j)
            ATL_vmac(rC0_@(j), rA0, rB0);
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp j @(j) 1 +
            @skip if (bc==0 && j%vl==0)
            @iexp kk @(bc) 0 = @(vl) @(j) % 0 = &
            @iif kk ! 0
               @iexp kk @(vl) @(j) / -1 +
               @iexp jj @(kk) @(vl) *
         @SKIP *************** LAST_ITER: increment pB before Loading *********
         @iif TRMML ! 0
            @iif jj = 0
               @callproc lKpBinc
            @endiif 
         @endiif
         @SKIP **************************************************************
             ATL_vld(vB@(kk), pB+@(jj));
            @endiif
         @endiwhile
            pB += @(incBk);
      @endiif
   @endiif
@SKIP 2-D case assumes all but last rB already loaded
   @iif DN = 0
      @define jb @0@
      @iexp j 0 0 +
      @iwhile j < @(vnu)
         @iexp jb 0 @(B1R) = @(j) *
         @iif B1R ! 0
            @callproc ldB 12 rB0 @(j)
            @iif jl = j
               pB += @(incBk);
            @endiif
         @endiif
         @iexp i 0 0 +
         @iwhile i < @(vmu)
            @iexp mo 0 0 +
            ATL_vmac(rC@(i)_@(j), rA@(i), rB@(jb));
            @skip if ((i|j|B1R) == 0)
            @iif @iexp @(i) @(j) | @(B1R) | 0 =
                  @iexp kk @(jl) @(bmul) *
               @callproc ldB 12 rB@(jl) @(jl)
                  @ifdef lb
                     @iexp kk @(lb) @(vl) *
                  @SKIP **********************incBn before load of pB[0]
                  @iif kk = 0 
                     @iif TRMML ! 0
                        @callproc lKpBinc
                     @endiif 
                  @endiif 
                  @SKIP ************************************************
               ATL_vld(vB@(lb), pB+@(kk));
                     @undef lb
                     @iexp mo 1 0 +
                  @endifdef
               pB += @(incBk);
            @endiif
            @iif j = jl
               @iexp kk @(i) @(vl) *
               ATL_vld(rA@(i), pA+@(kk));
               @iexp mo 1 0 +
               @iif i = il
               pA += @(incAk);
               @endiif
            @endiif
            @skip if (j != jl && i == il && !B1R)
            @iif @iexp @(j) @(jl) ! @(i) @(il) = & @(B1R) 0 = &
               @iexp kk @(j) @(bmul) *
               @callproc ldB 12 rB@(j) @(j)
            @endiif
            @iif mo = 0
               @ifdef lb
                  @iexp kk @(lb) @(vl) *
                  @SKIP *********************incBn before load of pB[0]
                  @iif kk = 0 
                     @iif TRMML ! 0
                        @callproc lKpBinc
                     @endiif 
                  @endiif 
                  @SKIP ***********************************************
               ATL_vld(vB@(lb), pB+@(kk));
                  @undef lb
                  @iexp mo 1 0 +
               @endifdef
            @endiif
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
      @undef jb
   @endiif
@SKIP pop our defs so caller's macros of same name aren't changed
   @undef DN
   @undef i
   @undef j
   @undef kk
@ENDPROC
@BEGINPROC ReloadlB
   @define kk @0@
   @define mo0 @0@ 
   @define i @0@ 
   @define j @0@ 
   @iif bc = 0
      @iexp j 0 0 +
      @iwhile j < @(vnu)
         @iexp kk @(vl) @(j) /
               ATL_vld(vB@(kk), pB+@(j));
         @iexp j @(j) @(vl) +
      @endiwhile
   @endiif
   @iif @iexp 1 @(vmu) > 0 @(B1R) = &
      @SKIP **NOTE: don't want to affect the 'mo' calc
      @iexp mo0 @(mo) =
      @iexp j 0 0 +
      @iwhile j < @(jl)
         @callproc ldB 12 rB@(j) @(j)
         @ifdef lb
            @iif ib < 0
               @iexp kk @(vl) @(lb) *
               ATL_vld(vB@(lb), pB+@(kk)); 
            @endiif
            @iif ib > -1 
               ATL_vld(vB@(lb), pB+@(ib));  
               @iexp ib @(ib) @(vl) +
            @endiif
            @undef lb
         @endifdef
         @iexp j @(j) 1 +
      @endiwhile
      @SKIP **restore previous mo **
      @iexp mo @(mo0) =
   @endiif
   @undef j
   @undef i
   @undef mo0
   @undef kk
@ENDPROC
void ATL_USERMM
(
   ATL_CSZT nmus,
   ATL_CSZT nnus,
   ATL_CSZT K,
   const @(typ) *pA, /* @(mu)*KB*nmus-length access-major array of A */
   const @(typ) *pB, /* @(nu)*KB*nnus-length access-major array of B */
   @(typ) *pC,   /* @(mu)*@(nu)*nnus*nmus-length access-major array of C */
   const @(typ) *pAn, /* next block of A */
   const @(typ) *pBn, /* next block of B */
   const @(typ) *pCn  /* next block of C */
)
/*
 * Performs a GEMM with M,N,K unrolling (& jam) of (@(mu),@(nu),@(ku)).
@VEC KDIM ` * Vectorization of VLEN=@(vl) along K dim, vec unroll=(@(vmu),@(vnu),@(vku)).`
@VEC MDIM ` * Vectorization of VLEN=@(vl) along M dim, vec unroll=(@(vmu),@(vnu),@(vku)).`
@VEC NO   ` * Code is not vectorized (VLEN=@(vl)).`
@iif kb = 0
 * You may set compile-time constant K dim by defining ATL_MM_KB.
@endiif
 */
{
   @declare "   register ATL_VTYPE " y n ";"
      @iif bc = 0
         @iexp kk @(vl) @(vnu) /
         @iexp j 0 0 +
         @iwhile j < @(kk)
            vB@(j)
            @iexp j @(j) 1 +
         @endiwhile
      @endiif
      @iif B1R ! 0
         rB0
      @endiif
      @iexp j 0 0 +
      @iwhile j < @(vnu)
         @iif @iexp 0 @(TWOD) ! 0 @(B1R) = &
            rB@(j)
         @endiif
         @iexp i 0 0 +
         @iwhile i < @(vmu)
            rC@(i)_@(j)
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
      @iif TWOD = 0
         rA0 
         @iif B1R = 0
            rB0
         @endiif
      @endiif
      @iif TWOD ! 0
         @iexp i 0 0 +
         @iwhile i < @(vmu)
            rA@(i)
            @iexp i @(i) 1 +
         @endiwhile
      @endiif
      @SKIP if (mu*nu < vlen && mu != 1 && nu != 1
      @iif @iexp @(vl) @(mu) @(nu) * < @(mu) 1 ! & @(nu) 1 ! &
         rtmp
         @define exreg @rtmp@
      @endiif
   @enddeclare
   @iif @iexp @(vl) @(mu) @(nu) * > 
      @define exreg @rC0_0@
   @endiif
   @ifdef ! exreg
      @iif @iexp @(mu) 1 = @(nu) 1 = |
         @define exreg @rB0@
      @endiif
   @endifdef
   @declare "   const @(typ) " y n ";"
    *pB0=pB *pA0=pA
   @enddeclare
   @iif npfA > 0
   const int incAN = (ATL_MM_KB * @(mu)) / nnus;
   @endiif
   @iif npfB > 0
   const int incBN = (ATL_MM_KB * @(nu)) / nmus;
   @endiif
@skip   const @(typ) *pfA;
   int i, j, k;
   @iif TRMML ! 0
   int I, KK; /* Used for K-loop bounds */
      @iexp koff @(mu)
      @iif mu < @(ku)
         @iexp koff @(ku)
      @endiif
   @endiif
   @iif TRMM = 1
   /* For Left-lower */
   int incAm = @(mu)*@(koff);
   int incBn = K < @(koff) ? 0 : @(nu)*(K - @(koff));
      @iif mu < @(ku)
      int off = 0;
      @endiif
   @endiif
   @iif TRMM = 2
   /* For Left-upper */
   int incAm = @(mu)*K;
   int incBn = 0;
      @iif mu < @(ku)
      int off = 0;
      @endiif
   @endiif
   @iif TRMMR ! 0
   int J, KK; /* Used for K-loop bounds */
   /* For Right-lower/upper */
   const int incAm = @(mu)*K;
   @skip to avoid compilation error
   const int incBn = @(nu)*K; /* just to use in pref*/
   @endiif
   @iif TRMM = 0
   #if ATL_KBCONST == 0
      int incAm = @(mu)*K, incBn = @(nu)*K;
   #else
      #define incAm (@(mu)*ATL_MM_KB)
      #define incBn (@(nu)*ATL_MM_KB)
   #endif
   @endiif

   @SKIP if (npfA > 0 & npfB > 0)
   @iexp kk 0 @(npfA) > 0 @(npfB) > &
   @iif kk ! 0
   pAn = (pAn != pA) ? pAn : pC;
   pBn = (pBn != pB) ? pBn : pC;
   @endiif
   @iif kk = 0
      @iif npfA > 0
         if (pAn == pA)
            pAn = (pBn != pB) ? pBn : pCn;
      @endiif
      @iif npfB > 0
         if (pBn == pB)
            pBn = (pAn != pA) ? pAn : pCn;
      @endiif
   @endiif
   @iexp mo 0 0 +
   @iexp ipf 0 0 +
   @iexp ipa 0 0 +
   @iexp ipb 0 0 +
   @iexp jl @(vnu) -1 +
   @iexp il @(vmu) -1 +
   @iif vnu > 2
      @iexp jpf 0 1 +
   @endiif
   @iif vnu < 3
      @iexp jpf 0 -1 +
   @endiif
   @iexp jpf 0 -1 +
@iif @iexp @(DOMLOOP)
   @iif TRMML = 0
   for (i=0; i < nmus; i++)
   @endiif
   @iif TRMML ! 0
   for (i=0, I=0; i < nmus; i++, I+=@(mu))
   @endiif
   {
   @iif TRMM = 3
      int Aoff = 0;
   @endiif
   @iif TRMMR ! 0
      @iif nu < @(ku)
      int off = 0;
      @endiif
   @endiif
@endiif
@print NOK=@(NOKLOOP) ib=@(ib) ia=@(ia)
   @iif bc = 0
      @iexp j 0 0 +
      @iwhile j < @(vnu)
         @iexp kk @(vl) @(j) /
      ATL_vld(vB@(kk), pB+@(j));
         @iexp j @(j) @(vl) +
      @endiwhile
      @iif NOKLOOP ! 0
         @iexp ib @(ib) @(nu) +
      @endiif
      @iif NOKLOOP = 0
      @SKIP ********* TRMML: to keep track of inc of pB before NLOOP   
         @iif TRMML ! 0
            @iexp PBINC 1 0 + 
         @endiif
      @SKIP ***********************************************************
      pB += @(incBk);
      @endiif
   @endiif
   @iif @iexp 1 @(vmu) > 0 @(B1R) = &
      @iexp j 0 0 +
      @iwhile j < @(jl)
         @callproc ldB 3 rB@(j) @(j)
         @ifdef lb
            @iif ib < 0
               @iexp kk @(vl) @(lb) *
      ATL_vld(vB@(lb), pB+@(kk)); 
            @endiif
            @iif ib > -1 
      ATL_vld(vB@(lb), pB+@(ib));  
               @iexp ib @(ib) @(vl) +
            @endiif
            @undef lb
         @endifdef
         @iexp j @(j) 1 +
      @endiwhile
   @endiif
@SKIP ************* TRMML: to keep track whether ld of pB actually hoisted  
@iif TRMML ! 0
   @iif bc = 0
      @iif vnu > 0
         @iexp PBLHOIST 0 1 +
      @endiif
   @endiif
   @iif @iexp 1 @(vmu) > 0 @(B1R) = &
      @iif jl > 0
         @iexp PBLHOIST 0 1 +
      @endiif
   @endiif
@endiif
@SKIP *****************************************************************
   @iif @iexp @(DONLOOP)
      @iif TRI = 0
         @iif TRMMR = 0 /* For Left TRMM or GEMM */
      for (j=0; j < nnus; j++)
         @endiif
         @iif TRMMR ! 0 /* For Right TRMM */
      for (j=0, J=0; j < nnus; j++, J+=@(nu))
         @endiif
      @endiif
      @iif TRI = 1
         @iif mEn = 1
      for (j=0; j <= i; j++)
         @endiif
         @iif mEn ! 1
            @iif ma > 1
      for (j=0; j < @(ma)*(i+1); j++)
            @endiif
            @iif na > 1
      for (j=0; j <= i/@(na); j++)
            @endiif
         @endiif
      @endiif
      {         
   @endiif
   @iif NOKLOOP ! 0
      @iif TRMM ! 0
         @abort "Not considered fully unrolled Kloop for TRMM!"
      @endiif
      @iexp IN_K 0 0 +
         @CALLPROC DoIter0_k
      @VEC KDIM `@iexp incK @(vl) 0 +`
      @VEC ! KDIM `@iexp incK 1 0 +`
      @iexp k 0 @(incK) +
      @iwhile ipf < npf
            /* Peel K=@(k) iteration for prefetch  */
         @CALLPROC DoIter_k
         @iexp k @(k) @(incK) +
      @endiwhile
      @iexp IN_K 1 0 +
      @iwhile k < kb
            /* K=@(k) iteration */
         @CALLPROC DoIter_k
         @iexp k @(k) @(incK) +
      @endiwhile
   @endiif
   @iif NOKLOOP = 0
      @SKIP ********* TRMM: to manage loop bound of TRMM ********
      @iif TRMM = 1 /* Left-lower */
         @iif mu < @(ku)
         KK = I-off+@(ku) ; 
         @endiif
         @iif mu } @(ku)
         KK = K < (I+@(mu)) ? K : (I+@(mu));
         @endiif
      @endiif
      @iif TRMM = 4 /* Right-upper */
         KK = K < (J+@(nu)) ? K : (J+@(nu));
      @endiif
      @SKIP ************************************************
         /* Peel K=0 iteration to avoid zero of rCxx and extra add  */
      @iexp IN_K 0 0 +
      @iexp npeel 1 0 +
      @VEC KDIM `@iexp kmul @(vl)`
      @VEC ! KDIM `@iexp kmul 1`
      @CALLPROC DoIter0
      @iwhile ipf < npf
/*
 *       Peel K=@(npeel) iter to allow prefetch of C or next blocks of A&B
 */
         @iexp kk @(kmul) @(npeel) *
         @iif TRMM = 0  
         if (K == @(kk))
         @endiif
         @iif TRMM = 1  
         if (KK <= @(kk))
      @SKIP ***** TRMM=1 and ld of pB hoisted case ***   
      @iif PBLHOIST ! 0
         {
            if (incBn)
            {
            @iif PBINC = 1
               pB += (incBn-@(incBk));
               @callproc ReloadlB
               pB += @(incBk);
            @endiif
            @iif PBINC = 0
               pB += incBn;
               @callproc ReloadlB
            @endiif 
            }
      @endiif
      @SKIP ******************************************   
         @endiif
         @iif TRMM = 2
            @iif mu < @(ku)
         if ((I-off+@(kk)) >= K)
            @endiif
            @iif mu } @(ku)
         if ((I+@(kk)) >= K)
            @endiif
      @SKIP ***** TRMM=2 ld of pB hoisted case ******   
      @iif PBLHOIST ! 0
         {
            if (incBn)
            {
            @iif PBINC = 1
               pB += (incBn-@(incBk));
               @callproc ReloadlB
               pB += @(incBk);
            @endiif 
            @iif PBINC = 0
               pB += incBn;
               @callproc ReloadlB
            @endiif 
            }
      @endiif
      @SKIP **************************************   
         @endiif
         @iif TRMM = 3
            @iif nu < @(ku)
         if ((J-off+@(kk)) >= K)
            @endiif
            @iif nu } @(ku)
         if ((J+@(kk)) >= K)
            @endiif
         @endiif
         @iif TRMM = 4
         if (KK <= @(kk))
         @endiif
            goto KDONE;
         @iif TRMML ! 0
            @iif PBLHOIST ! 0
         }
            @endiif
         @endiif
            @CALLPROC DoIter
         @iexp npeel @(npeel) 1 +
      @endiwhile
      @SKIP peel until npeel%vku == 0
      @iif @iexp @(vku) @(npeel) % 0 !
         @iexp nep @(vku) @(npeel) % @(vku) -
/*
 *       Peeled @(npeel) iters, peel another @(nep) to make mul of vku=@(vku)
 */
         @iexp ii 0
         @iwhile ii < nep
         /* ku mulpeel @(ii) of @(nep) */
         @iexp kk @(kmul) @(npeel) *
         @iif TRMM = 0
         if (K == @(kk))
         @endiif
         @iif TRMM = 1  
         if (KK <= @(kk))
      @SKIP ***** TRMM=1 ld of pB hoisted case *********   
            @iif PBLHOIST ! 0
         {           
            if (incBn)
            {
            @iif PBINC = 1
               pB += (incBn-@(incBk));
               @callproc ReloadlB
               pB += @(incBk);
            @endiif
            @iif PBINC = 0
               pB += incBn;
               @callproc ReloadlB
            @endiif
            }
            @endiif
      @endiif
      @SKIP *********************************************   
         @iif TRMM = 2
            @iif mu < @(ku)
         if ((I-off+@(kk)) >= K)
            @endiif
            @iif mu } @(ku)
         if ((I+@(kk)) >= K)
            @endiif
      @SKIP ***** TRMM=2 ld of pB hoisted case *********   
      @iif PBLHOIST ! 0
         {
            if (incBn)
            {
            @iif PBINC = 1
               pB += (incBn-@(incBk));
               @callproc ReloadlB
               pB += @(incBk);
            @endiif
            @iif PBINC = 0
               pB += incBn;
               @callproc ReloadlB
            @endiif
            }
      @endiif
      @SKIP *******************************************   
         @endiif
         @iif TRMM = 3
            @iif nu < @(ku)
         if ((J-off+@(kk)) >= K)
            @endiif
            @iif nu } @(ku)
         if ((J+@(kk)) >= K)
            @endiif
         @endiif
         @iif TRMM = 4
         if (KK <= @(kk))
         @endiif
            goto KDONE;
      @SKIP ***** TRMM left,  B1R=0 ******************   
         @iif TRMML ! 0
            @iif PBLHOIST ! 0
         }
            @endiif 
         @endiif
      @SKIP ****************************************** 
            @CALLPROC DoIter
            @iexp npeel @(npeel) 1 +
            @iexp ii @(ii) 1 +
         @endiwhile
      @endiif
         @iexp kk @(kmul) @(npeel) *
      @iif TRMM = 1 /* Left-lower */
         @SKIP ****NOTE: extra checking needed if kloop not executes   
         @iif PBLHOIST ! 0
         if (KK == @(kk))
         {
            if (incBn)
            {
            @iif PBINC = 1
               pB += (incBn-@(incBk));
               @callproc ReloadlB
               pB += @(incBk);
            @endiif
            @iif PBINC = 0
               pB += incBn;
               @callproc ReloadlB
            @endiif
            }
            goto KDONE;
         }
         KK -= @(ku); /* to keep epilogue for kloop */
         @endiif
         for (k=@(kk); k < KK; k += @(ku))
      @endiif
      @iif TRMM = 2 /* Left-upper */
         @SKIP ****NOTE: extra checking needed if kloop not executes   
         @iif PBLHOIST ! 0 
            @iif mu < @(ku)
         if ((I-off+@(kk)) >= K)
            @endiif
            @iif mu } @(ku)
         if ((I+@(kk)) >= K)
            @endiif
         {
            if (incBn)
            {
            @iif PBINC = 1
               pB += (incBn-@(incBk));
               @callproc ReloadlB
               pB += @(incBk);
            @endiif
            @iif PBINC = 0
               pB += incBn;
               @callproc ReloadlB
               @SKIP pB += @(incBk);
            @endiif 
            }
            goto KDONE;
         }
         KK = K - @(ku); /* to keep epilogue for kloop */
            @iif mu < @(ku)
         for (k=I-off+@(kk); k < KK; k += @(ku))
            @endiif
            @iif mu } @(ku)
         for (k=I+@(kk); k < KK; k += @(ku))
            @endiif
         @endiif
         @iif PBLHOIST = 0
            @iif mu < @(ku)
         for (k=I-off+@(kk); k < K; k += @(ku))
            @endiif
            @iif mu } @(ku)
         for (k=I+@(kk); k < K; k += @(ku))
            @endiif
         @endiif
      @endiif
      @iif TRMM = 3 /* Right-lower */
            @iif nu < @(ku)
         for (k=J-off+@(kk); k < K; k += @(ku))
            @endiif
            @iif nu } @(ku)
         for (k=J+@(kk); k < K; k += @(ku))
            @endiif
      @endiif
      @iif TRMM = 4 /* Right-upper */
         for (k=@(kk); k < KK; k += @(ku))
      @endiif
         @iif TRMM = 0
         for (k=@(kk); k < ATL_MM_KB; k += @(ku))
         @endiif
         {
            @iexp IN_K 0 1 +
            @iexp kk 0
            @iwhile kk < @(vku)
            @iif kk > 0

            @endiif
            @CALLPROC DoIter
               @iexp kk @(kk) 1 +
            @endiwhile
         }
      @SKIP *******TRMML: special for TRMML ******************
      @iif TRMML ! 0
         @iif PBLHOIST ! 0 
      @SKIP ****** handle last iteration differently *********
      @iexp IN_K 0 1 +
      @iexp kk 0
      @iwhile kk < @(vku)
         @iexp kk @(kk) 1 +
         @iif kk < @(vku)
         @CALLPROC DoIter 
         @endiif
         @iif kk = @(vku)
/*    last iteration : need to update pB accordingly */   
            @define LAST_ITER @1@
            @CALLPROC DoIter 
            @SKIP @undef LAST_ITER
         @endiif
      @endiwhile
KDONE:
         @endiif
            @iif PBLHOIST = 0
         @iif npeel > 1
KDONE:
         @endiif
            @endiif
      @endiif
      @SKIP ******* end of TRMML ***********************
      @iif TRMML = 0
         @iif npeel > 1
KDONE:
         @endiif
      @endiif
   @endiif
         @CALLPROC storeC 6
         @VEC KDIM   `@iexp kk @(vl) @(mu) @(nu) * @(vl) + -1 + / @(vl) *`
         @VEC ! KDIM `@iexp kk @(mu) @(nu) *`
   @iif @iexp @(DOMLOOP) @(DONLOOP) |
         pC += @(kk);
   @iif TRMM = 0
      @iif NOKLOOP ! 0
         pB += incBn;
      @endiif
      @iif ku ! kb
         pA = pA0;
      @endiif
   @endiif
      @iif TRMM ! 0
         @iif TRMML ! 0
            @iif PBLHOIST = 0
         pB += incBn;
            @endiif
         @SKIP /*pB += incBn;*/
         pA = pA0;
         @endiif
         @iif TRMM = 3
         @iif nu < @(ku)
         off += @(nu); 
         if (off >= @(ku)) { off -= @(ku); Aoff += @(mu)*@(ku); }
         @endiif
         @iif nu } @(ku)
         Aoff += @(mu)*@(nu);
         @endiif
         pA = pA0 + Aoff; /* for Right-lower, adjust starting point */
         @endiif
         @iif TRMM = 4
         pA = pA0; /* for Right-upper, go to original start */
         @endiif
      @endiif
   @endiif
   @iif @iexp @(DONLOOP)
      }  /* end of loop over N */
   @endiif
   @iif @iexp @(DOMLOOP)
      @iif TRMML = 0
      pB = pB0;
      pA0 += incAm;
      pA = pA0;
      @endiif
      @iif TRMML ! 0
         pA0 += incAm;
         pA = pA0;
         pB = pB0;
      @iif TRMM = 1
         @iif mu < @(ku)
         off += @(mu);
         if (off >= @(ku)) 
         {
            off -= @(ku);
            incAm += @(mu)*@(ku); incBn -= @(nu)*@(ku);
         }
         @endiif
         @iif mu } @(ku)
            incAm += @(mu)*@(mu);
            incBn -= @(nu)*@(mu);
         @endiif
         incBn = incBn < 0 ? 0 : incBn;
      @endiif
      @iif TRMM = 2
         @iif mu < @(ku)
         off += @(mu);
         if (off >= @(ku)) 
         {
            off -= @(ku);
            incAm -= @(mu)*@(ku); incBn += @(nu)*@(ku);
         }
         @endiif
         @iif mu } @(ku)
            incAm -= @(mu)*@(mu);
            incBn += @(mu)*@(nu);
         @endiif
         pB += incBn;
      @endiif
      @endiif
   }  /* end of loop over M */
   @endiif
}

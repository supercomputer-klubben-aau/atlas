@ifdef ! kmaj
   @define kmaj @0@
@endifdef
@iif kmaj = 1
   @iexp kmaj 0 0 +
@endiif
@ROUT ATL_am2rm ATL_rm2am ATL_crm2am
   @iexp mku @(mu) @(ku) %
   @iexp kmu @(ku) @(mu) %
   @iif mku ! 0
      @iif kmu ! 0
         @abort "mu (@(mu)) must be multiple of or divisible by ku (@(ku))!" 
      @endiif
   @endiif
@ROUT ATL_am2cm ATL_cm2am ATL_ccm2am
   @iexp nku @(nu) @(ku) %
   @iexp knu @(ku) @(nu) %
   @iif nku ! 0
      @iif knu ! 0
         @abort "nu (@(nu)) must be multiple of or divisible by ku (@(ku))!"
      @endiif
   @endiif
@ROUT ATL_am2rm ATL_am2cm ATL_cm2am ATL_rm2am ATL_ablk2cmat ATL_cmat2ablk @\
      ATL_cam2rm ATL_cam2cm ATL_ccm2am ATL_crm2am ATL_cablk2cmat ATL_ccmat2ablk
#include "atlas_misc.h"
   @ifdef ! alpha
      @define alpha @1@
   @endifdef
   @iif alpha = 1
      @define malp @@
      @define calp @-@
   @endiif
   @iif alpha = -1
      @define malp @-@
      @define calp @@
      @define nalp @n@
   @endiif
   @iif alpha ! -1
      @define nalp @@(alpha)@
      @iif alpha ! 1
         @define malp @alpha*@
         @define calp @(-alpha)*@
         @define nalp @X@
      @endiif
   @endiif
@ROUT ATL_am2cm ATL_cm2am ATL_rm2am
   @ifdef ! dupB
      @define dupB @1@
   @endifdef
   @iif dupB = 0
      @undef dupB
      @define dupB @1@
   @endiif
   @iif dupB < 2
      @define dsuf @@
      @iexp incdup @(nu) 0 +
   @endiif
   @iif dupB > 1
      @define dsuf @d@(dupB)@
      @iexp incdup @(dupB) @(nu) *
   @endiif
@ROUT ATL_rm2am ATL_cm2am
   @define cnst @const @
   @define cnstb @@
@ROUT ATL_am2cm ATL_am2rm
   @define cnst @@
   @define cnstb @const @
@ROUT ATL_am2cm ATL_cm2am
@iif kmaj = 1
   @iexp kmaj 0 0 +
@endiif
@ifdef ! ku
   @iif kmaj = 0
      @define ku @1@
   @endiif
@endifdef
@beginproc proc_cm2am_kvec_blk k n
   @iexp j 0
   @iwhile j < @(n)
      @iexp i 0
      @iwhile i < @(ku)
         @iexp ib @(j) @(ku) *
         @iexp ib @(ib) @(i) +
         @iif i < k
@ROUT ATL_am2cm
         A@(j)[i+@(i)] = @(malp)b[@(ib)];
@ROUT ATL_cm2am
         b[@(ib)] = @(malp)A@(j)[i+@(i)];
@ROUT ATL_am2cm ATL_cm2am 
         @endiif
         @iif i } k
@ROUT ATL_cm2am 
         b[@(ib)] = ATL_rzero;
@ROUT ATL_am2cm ATL_cm2am 
         @endiif
         @iexp i @(i) 1 +
      @endiwhile
      @iexp j @(j) 1 +
   @endiwhile
@ROUT ATL_cm2am 
   @iwhile j < @(nu)
      @iexp i 0
      @iwhile i < @(ku)
         @iexp ib @(j) @(ku) *
         @iexp ib @(ib) @(i) +
         b[@(ib)] = ATL_rzero;
         @iexp i @(i) 1 +
      @endiwhile
      @iexp j @(j) 1 +
   @endiwhile
@ROUT ATL_am2cm ATL_cm2am 
@endproc
@beginproc proc_cm2am_kvec_blkR
      if (Kr)
      {
         /* copy last partial non-diag block */
         for (k=0; k<Kr; k++)
         {
            @iexp j 0
            @iwhile j < @(nu)
               @iexp ib @(j) @(ku) *
@ROUT ATL_cm2am `            b[@(ib)+k] = @(malp)A@(j)[i+k];`
@ROUT ATL_am2cm `            A@(j)[i+k] = @(malp)b[@(ib)+k];`
               @iexp j @(j) 1 +
            @endiwhile
         }
@ROUT ATL_cm2am 
         /* now pad if needed */
         for ( ; k<@(ku); k++)
         {
            @iexp j 0
            @iwhile j < @(nu)
               @iexp ib @(j) @(ku) *
            b[@(ib)+k] = ATL_rzero;
               @iexp j @(j) 1 +
            @endiwhile
         }
@ROUT ATL_am2cm ATL_cm2am 
         b += @(binc);
      }
@endproc
@beginproc proc_cm2am_diag1 bi isup
   @iif i < @(j)
      @iif isup = 1
@ROUT ATL_cm2am `         b[@(bi)] = @(malp)A@(j)[i+@(i)];`
@ROUT ATL_am2cm `         A@(j)[i+@(i)] = @(malp)b[@(bi)];`
      @endiif      
      @iif isup = 0
@ROUT ATL_cm2am `         b[@(bi)] = ATL_rzero;`
      @endiif      
   @endiif
   @iif i = @(j)
      #ifdef UnitDiag_
@ROUT ATL_cm2am `         b[@(bi)] = @(malp)ATL_rone;`
      #else
@ROUT ATL_cm2am `         b[@(bi)] = @(malp)A@(j)[i+@(i)];`
@ROUT ATL_am2cm `         A@(j)[i+@(i)] = @(malp)b[@(bi)];`
      #endif
   @endiif
   @iif i > @(j)
      @iif isup = 1
@ROUT ATL_cm2am `         b[@(bi)] = ATL_rzero;`
      @endiif      
      @iif isup = 0
@ROUT ATL_cm2am `         b[@(bi)] = @(malp)A@(j)[i+@(i)];`
@ROUT ATL_am2cm `         A@(j)[i+@(i)] = @(malp)b[@(bi)];`
      @endiif      
   @endiif
@endproc
@beginproc proc_cm2am_kvec_diag k n isup
   @iexp j 0
   @iif nu { @(ku)
   @iwhile j < @(n)
      @iexp i 0
      @iwhile i < @(ku)
         @iexp ib @(j) @(ku) *
         @iexp ib @(ib) @(i) +
         @iif i < @(k)
            @callproc proc_cm2am_diag1 @(ib) @(isup)
         @endiif
         @iif i } @(k)
@ROUT ATL_cm2am `      b[@(ib)] = ATL_rzero;`
         @endiif
         @iexp i @(i) 1 +
      @endiwhile
      @iexp j @(j) 1 +
   @endiwhile
   @iwhile j < @(nu)
      @iexp i 0
      @iwhile i < @(ku)
         @iexp ib @(j) @(ku) *
         @iexp ib @(ib) @(i) +
@ROUT ATL_cm2am `      b[@(ib)] = ATL_rzero;`
         @iexp i @(i) 1 +
      @endiwhile
      @iexp j @(j) 1 +
   @endiwhile
      b += @(binc);
   @endiif
   @iif nu > @(ku)
      /* for nu > ku, use rolled loop for copying (nu x nu) diag-blk */
      {
      @iexp KK @(k) @(ku) +
      @iexp KK @(KK) -1 +
      @iexp KK @(ku) @(KK) /
      @iexp KK @(ku) @(KK) *
         int di, dj;
         const TYPE *pA = A0 + i;
         TYPE *pb;
         for (dj=0; dj<@(n); dj++, pA+=lda)
         {
            pb = b + dj*@(ku);
            int doff = 0;
            for (di=0; di<dj; di++)
            {
               @iif isup = 1
               pb[doff] = @(malp)pA[di];
               @endiif
               @iif isup = 0
               pb[doff] = ATL_rzero;
               @endiif
               doff++;
               if (doff >= @(ku))
               {
                  doff = 0;
                  pb += @(binc);
               }
            }
            /* now the diagonal element */
            #ifdef UnitDiag_
               pb[doff] = @(malp)ATL_rone;
            #else
               pb[doff] = @(malp)pA[di];
            #endif
            doff++;
            if (doff >= @(ku))
            {
               doff = 0;
               pb += @(binc);
            }
            di++;
            /* now below-diag elems */
            for ( ; di<@(k); di++)
            {
               @iif isup = 1
               pb[doff] = ATL_rzero;
               @endiif
               @iif isup = 0
               pb[doff] = @(malp)pA[di];
               @endiif
               doff++;
               if (doff >= @(ku))
               {
                  doff = 0;
                  pb += @(binc);
               }
            }
            @iif k < @(KK)
            /* now below-diag padding */
            for ( ; di<@(KK); di++)
            {
               pb[doff] = ATL_rzero;
               doff++;
               if (doff >= @(ku))
               {
                  doff = 0;
                  pb += @(binc);
               }
            }
            @endiif
         }
         @iif n < @(nu)
         for ( ; dj<@(nu); dj++)
         {
            pb = b + dj*@(ku);
            int doff = 0;
            for (di=0; di<@(KK); di++)
            {
               pb[doff] = ATL_rzero;
               doff++;
               if (doff >= @(ku))
               {
                  doff = 0;
                  pb += @(binc);
               }
            }
         }
         @endiif
         b += @(nu)*@(nu);
      }
   @endiif
@endproc
@beginproc proc_cm2am_kvec_diagR k n isup
      {
         int di, dj;
         const TYPE *pA = A0 + i;
         /* now copy the diag part */
         for (dj=0; dj<@(n); dj++, pA+=lda)
         {
            int dbound = off + dj;
            for (di=0; di<dbound; di++)
            {
               @iif isup = 1
                  b[dj*@(ku)+di] = @(malp)pA[di];
               @endiif
               @iif isup = 0
                  b[dj*@(ku)+di] = ATL_rzero;
               @endiif
            }
            /* now the diagonal element */
            #ifdef UnitDiag_
               b[dj*@(ku)+di] = @(malp)ATL_rone;
            #else
               b[dj*@(ku)+di] = @(malp)pA[di];
            #endif
            for (di++; di<@(k); di++)
            {
               @iif isup = 1
                  b[dj*@(ku)+di] = ATL_rzero;
               @endiif
               @iif isup = 0
                  b[dj*@(ku)+di] = @(malp)pA[di];
               @endiif
            }
            @iif isup = 0
               @iif k < @(ku)
               for ( ; di<@(ku); di++)
                  b[dj*@(ku)+di] = ATL_rzero;
               @endiif
            @endiif
         }
         @iif n < @(nu)
         /* now nu-padding */
         for ( ; dj<@(nu); dj++)
            for (di=0; di<@(ku); di++)
               b[dj*@(ku)+di] = ATL_rzero;
         @endiif
         b += @(binc);
      }
@endproc
@iif kmaj ! 0
   @define ku @@(kmaj)@
@ROUT ATL_am2cm
/* 
 * This routine copies from k-vectorized access-major block b to column-major
 * triangular submatrix A.
 */
void ATL_USERCPMM       /* access- to column-major */
(
   ATL_CSZT K,          /* number of rows/cols in triangular A */
   const SCALAR alpha,  /* scalar for b */
   const TYPE *b,       /* access-ku-major block holding A */
   TYPE *A,             /* OUTPUT: submatrix copied frm access-major format */
   ATL_CSZT lda         /* stride between row elements */
)
@ROUT ATL_cm2am 
/*
 * This routine copies the KxK triangular submatrix A into 
 * access-k-vlen-major storage.
 * In this storage, @(nu) vectors of @(ku) length are taken from the
 * @(nu) columns of A and stored in a @(ku)x@(nu) subblock.
 * CEIL(K/ku) of these subblocks are stored together to make a K-panel.
 * The CEIL(K/nu) K-panels are stored contiguously.  If ku does not evenly
 * divide K then the last block in the K-panel will be zero padded, and
 * the same is true for the NU portion of the every K-panel since only 1 in 
 * each nu-sized panels evenly divides N.
 */
void ATL_USERCPMM       /* column- to access-major */
(
   ATL_CSZT K,          /* number of rows/cols in triangular A */
   const SCALAR alpha,  /* scalar for A */
   const TYPE *A,       /* matrix to be copied to access-major format */
   ATL_CSZT lda,        /* stride between row elements */
   TYPE *b              /* OUTPUT: access-ku-major block holding A */
)
@ROUT ATL_am2cm ATL_cm2am 
{
   @iif nu } @(ku)
      @iexp koff @(nu)
   @endiif
   @iif nu < @(ku)
      @iexp koff @(ku)
   ATL_INT off = 0;
   @endiif
   ATL_CSZT n = (K/@(koff))*@(koff), incA = lda*@(nu), nr=K-n;
   ATL_CSZT Kr = K - (K/@(ku))*@(ku);
@skip   @ROUT ATL_am2cm `   ATL_CSZT KZ = KK-K, ZSKIP=KZ*@(incdup);`
   ATL_SZT i, j, k;
   @declare "   @(cnst)TYPE " n n ";"
      *A0=A
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *A@(j)=A@(i)+lda
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
   @iexp binc @(nu) @(ku) *

   for (j=0; j < n; j += @(nu))
   {
   #ifdef Upper_
         @iif nu < @(ku)
      for (i=0; i < (j-off); i += @(ku), b += @(binc))
      {
         /* subblock copy */
         @callproc proc_cm2am_kvec_blk @(ku) @(nu)
      }
      /* copy (off+@(nu))x@(nu) diag block */
      @callproc proc_cm2am_kvec_diagR @(ku) @(nu) 1
      off += @(nu); if (off >= @(ku)) off -= @(ku);
         @endiif
         @iif nu } @(ku)
      for (i=0; i < j; i += @(ku), b += @(binc))
      {
         /* subblock copy */
         @callproc proc_cm2am_kvec_blk @(ku) @(nu)
      }
      /* copy @(nu)x@(nu) diag block */
      @callproc proc_cm2am_kvec_diag @(nu) @(nu) 1
         @endiif
   #else
      /* copy @(koff)x@(nu) diag block */
         @iif nu < @(ku)
      i = j - off;
      @callproc proc_cm2am_kvec_diagR @(ku) @(nu) 0
      off += @(nu); if (off >= @(ku)) off -= @(ku);
         @endiif
         @iif nu } @(ku)
      i = j;
      @callproc proc_cm2am_kvec_diag @(nu) @(nu) 0
         @endiif

      for (i+=@(koff); i < (K-Kr); i += @(ku), b += @(binc))
      {
         /* subblock copy */
         @callproc proc_cm2am_kvec_blk @(ku) @(nu)
      }
      @callproc proc_cm2am_kvec_blkR
   #endif

      @iexp j 0 0 +
      @iwhile j < @(nu)
      A@(j) += incA;
      @iexp j @(j) 1 +
      @endiwhile
   }
   @iif koff ! 1
   switch(nr)
   {
   @iexp n 1 0 +
   @iwhile n < @(koff)
   case @(n): /* If nu < ku: may require multiple panel */
   @iexp nn @(nu) @(nu) @(n) / *
   @iexp nr @(n) -@(nn) +
   #ifdef Upper_
      @iexp jn 0
      @iwhile jn < @(nn)
      @skip this section means nu < ku
      for (i=0; i < (j-off); i += @(ku), b += @(binc))
      {
         /* subblock copy */
         @callproc proc_cm2am_kvec_blk @(ku) @(nu)
      }
      /* copy (off+@(nu))x@(nu) diag blk */
      @callproc proc_cm2am_kvec_diagR @(ku) @(nu) 1
      off += @(nu); if (off >= @(ku)) off -= @(ku);
      @iexp j 0
      @iwhile j < @(nu)
      A@(j) += incA;
         @iexp j @(j) 1 +
      @endiwhile
      j += @(nu);
         @iexp jn @(jn) @(nu) +
      @endiwhile
      @iif nr > 0
      /* now the last nu-panel (partial) */
         @iif nu < @(ku)
      for (i=0; i < (j-off); i += @(ku), b += @(binc))
      {
         /* subblock copy */
         @callproc proc_cm2am_kvec_blk @(ku) @(nr)
      }
      /* copy (off+@(nr))x@(nr) blk */
      @callproc proc_cm2am_kvec_diagR @(ku) @(nr) 1
         @endiif
         @iif nu } @(ku)
      for (i=0; i < j; i += @(ku), b += @(binc))
      {
         /* subblock copy */
         @callproc proc_cm2am_kvec_blk @(ku) @(nr)
      }
      /* copy @(nr)x@(nr) blk */
      @callproc proc_cm2am_kvec_diag @(nr) @(nr) 1 
         @endiif
      @endiif
   #else
      /* if lower triangle, then diag block is the only block to copy */
      @iexp jn 0
      @iwhile jn < @(nn)
      @skip this section means nu < ku
      i = j - off;
      @iexp pn @(n) -@(jn) +
      /* copy @(pn)x@(nu) low-diag */
      @callproc proc_cm2am_kvec_diagR @(n) @(nu) 0
      off += @(nu); if (off >= @(ku)) off -= @(ku);
      @iexp j 0
      @iwhile j < @(nu)
      A@(j) += incA;
         @iexp j @(j) 1 +
      @endiwhile
      j += @(nu);
         @iexp jn @(jn) @(nu) +
      @endiwhile
      @iif nr > 0
      /* now copy @(nr)x@(nr) blk */
         @iif nu < @(ku)
      i = j - off;
      @callproc proc_cm2am_kvec_diagR @(n) @(nr) 0
         @endiif
         @iif nu } @(ku)
      i = j;
      @callproc proc_cm2am_kvec_diag @(nr) @(nr) 0
         @endiif
      @endiif
   #endif
      break;
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
   @endiif
}
@endiif
@beginproc proc_cm2am_mvec_blk n
   @iexp j 0
   @iwhile j < @(nu)
      @iexp jk @(dupB) @(j) *
      @iexp k @(dupB) -1 +
      @iif j < @(n)
@ROUT ATL_cm2am 
      @iwhile k > 0
         b[@(jk)+@(k)] =
            @iexp k @(k) -1 +
      @endiwhile
         b[@(jk)] = @(malp)A@(j)[i];
@ROUT ATL_am2cm
         A@(j)[i] = @(malp)b[@(jk)];
@ROUT ATL_am2cm ATL_cm2am 
      @endiif
      @iif j } n
@ROUT ATL_cm2am 
         b[@(jk)] = ATL_rzero;
@ROUT ATL_am2cm ATL_cm2am 
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
@endproc
@beginproc proc_mvec_KPAD
   @iif ku > 1
      if (Kr)
      {
         /* pad @(ku)-Kr rows */
@ROUT ATL_am2cm
         b += (@(ku)-Kr)*@(incdup);
@ROUT ATL_cm2am 
         for (k=0; k < (@(ku)-Kr); k++, b += @(incdup))
         {
      @iexp j 0
      @iwhile j < @(nu)
            b[@(j)] =
         @iexp j @(j) 1 +
      @endiwhile
                  ATL_rzero;
         }
@ROUT ATL_am2cm ATL_cm2am 
      }
   @endiif
@endproc
@beginproc proc_cm2am_mvec_diag k n isup
   @iexp i 0
   @iwhile i < @(k)
      @iexp j 0
      @iwhile j < @(n)
         @callproc proc_cm2am_diag1 @(j) @(isup)
         @iexp j @(j) 1 +
      @endiwhile
@ROUT ATL_cm2am 
      @iwhile j < @(nu)
      b[@(j)] = ATL_rzero;
         @iexp j @(j) 1 +
      @endiwhile
@ROUT ATL_am2cm ATL_cm2am 
      b += @(incdup);
      @iexp i @(i) 1 +
   @endiwhile
@iif ku > 1
   @skip KK = ((n+ku-1) / ku) * ku
   @iexp KK @(ku) @(ku) 1 @(ku) - @(n) + / *
   @skip ZSKIP = (KK - n)*incdup
   @iexp ZSKIP @(n) @(KK) - @(incdup) *
@ROUT ATL_am2cm
      b += @(ZSKIP);
@ROUT ATL_cm2am 
   @iwhile i < @(KK)
      /* needs KU-padding */
      @iexp j 0
      @iwhile j < @(nu)
      b[@(j)] = ATL_rzero;
         @iexp j @(j) 1 +
      @endiwhile
      b += @(incdup);
      @iexp i @(i) 1 +
   @endiwhile
@ROUT ATL_am2cm ATL_cm2am 
@endiif
@endproc
@beginproc proc_cm2am_mvec_diagR k n isup
      {
         int di, dj;
         const TYPE *pA = A0 + i;
         /* now copy the diag part */
         for (dj=0; dj<@(n); dj++, pA+=lda)
         {
            int dbound = off + dj;
            for (di=0; di<dbound; di++)
            {
               @iif isup = 1
                  b[di*@(nu)+dj] = @(malp)pA[di];
               @endiif
               @iif isup = 0
                  b[di*@(nu)+dj] = ATL_rzero;
               @endiif
            }
            /* now the diagonal element */
            #ifdef UnitDiag_
               b[di*@(nu)+dj] = @(malp)ATL_rone;
            #else
               b[di*@(nu)+dj] = @(malp)pA[di];
            #endif
            for (di++; di<@(k); di++)
            {
               @iif isup = 1
                  b[di*@(nu)+dj] = ATL_rzero;
               @endiif
               @iif isup = 0
                  b[di*@(nu)+dj] = @(malp)pA[di];
               @endiif
            }
            @iif isup = 0
               @iif k < @(ku)
            /* bottom padding */
               for (; di<@(ku); di++)
                  b[di*@(nu)+dj] = ATL_rzero;
               @endiif
            @endiif
         }
         @iif n < @(nu)
         /* now nu-padding */
         for (di=0; di<@(ku); di++)
            for (dj=@(n); dj<@(nu); dj++)
               b[di*@(nu)+dj] = ATL_rzero;
         @endiif
         b += @(incdup)*@(ku);
      }
@endproc
@iif kmaj = 0
@ROUT ATL_am2cm
/*
 * Copies from (M-vectorized) access-major storage triangular block b back 
 * to column-major storage A, with possible scale.
 * For TRMM, this routine handles Notrans B matrices, and Trans A matrices.
 */
void ATL_USERCPMM       /* access-major blk 2 col-major submatrix */
(
   ATL_CSZT K,          /* number of rows/cols in triangular A */
   const SCALAR alpha,  /* scalar for b */
   const TYPE *b,       /* INPUT: access-major block holding A */
   TYPE *A,             /* OUTPUT: submatrix copied frm access-major b */
   ATL_CSZT lda         /* stride between row elements */
)
@ROUT ATL_cm2am 
/*
 * This routine copies the KxK triangular submatrix A into 
 * the CEIL(K/@(ku))xCEIL(K/@(mu)) block b.
 * In this storage, @(nu) vectors of @(ku) length are taken from the
 * @(nu) columns of A and stored in a @(ku)x@(nu) subblock.
 * CEIL(K/ku) of these subblocks are stored together to make a K-panel.
 * The CEIL(K/nu) K-panels are stored contiguously.  If ku does not evenly
 * divide K then the last block in the K-panel will be zero padded, and
 * similarly pad the last nu-panel if its size is less than @(nu).
 * For TRMM, this routine handles Notrans B matrices, and Trans A matrices.
 */
void ATL_USERCPMM       /* col-access matrix to access-major block */
(
   ATL_CSZT K,          /* number of rows/cols in triangular A */
   const SCALAR alpha,  /* scalar for A */
   const TYPE *A,       /* matrix to be copied to access-major format */
   ATL_CSZT lda,        /* stride between row elements */
   TYPE *b              /* OUTPUT: access-major block holding condensed A */
)
@ROUT ATL_am2cm ATL_cm2am 
{
   @iif nu } @(ku)
      @iexp koff @(nu)
   @endiif
   @iif nu < @(ku)
      @iexp koff @(ku)
   ATL_INT off = 0;
   @endiif
   ATL_CSZT n = (K/@(koff))*@(koff), incA = lda*@(nu), nr = K-n;
   @iif ku > 1
   ATL_CSZT Kr = K - (K/@(ku))*@(ku);
@skip   @ROUT ATL_am2cm `   ATL_CSZT KZ = KK-K, ZSKIP=KZ*@(incdup);`
   @endiif
   ATL_SZT i, j, k;
   @declare "   @(cnst)TYPE " n n ";"
      *A0=A
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *A@(j)=A@(i)+lda
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
   @undef cnst

   for (j=0; j < n; j += @(nu))
   {
   #ifdef Upper_
         @iif nu < @(ku)
      for (i=0; i < (j-off); i++, b += @(incdup))
      {
         /* subblock copy */
         @callproc proc_cm2am_mvec_blk @(nu)
      }
      /* copy (off+@(nu))x@(nu) diag block */
      @callproc proc_cm2am_mvec_diagR @(ku) @(nu) 1
      off += @(nu); if (off >= @(ku)) off -= @(ku);
         @endiif
         @iif nu } @(ku)
      for (i=0; i < j; i++, b += @(incdup))
      {
         /* subblock copy */
         @callproc proc_cm2am_mvec_blk @(nu)
      }
      /* copy @(nu)x@(nu) diag block */
      @callproc proc_cm2am_mvec_diag @(nu) @(nu) 1
         @endiif
   #else
      /* copy @(koff)x@(nu) diag block */
         @iif nu < @(ku)
      i = j - off;
      @callproc proc_cm2am_mvec_diagR @(ku) @(nu) 0
      off += @(nu); if (off >= @(ku)) off -= @(ku);
         @endiif
         @iif nu } @(ku)
      i = j;
      @callproc proc_cm2am_mvec_diag @(nu) @(nu) 0
         @endiif

      for (i+=@(koff); i < K; i++, b += @(incdup))
      {
         /* subblock copy */
         @callproc proc_cm2am_mvec_blk @(nu)
      }
      @callproc proc_mvec_KPAD
   #endif
      @iexp j 0
      @iwhile j < @(nu)
      A@(j) += incA;
         @iexp j @(j) 1 +
      @endiwhile
   }
   @iif koff ! 1
   switch(nr)
   {
   @iexp n 1 0 +
   @iwhile n < @(koff)
   case @(n): /* If nu < ku: may require multiple panel */
   @iexp nn @(nu) @(nu) @(n) / *
   @iexp nr @(n) -@(nn) +
   #ifdef Upper_
      @iexp jn 0
      @iwhile jn < @(nn)
      @skip This section means nu < ku
      for (i=0; i < (j-off); i++, b += @(incdup))
      {
         /* subblock copy */
         @callproc proc_cm2am_mvec_blk @(nu)
      }
      /* copy (off+@(nu))x@(nu) diag blk */
      @callproc proc_cm2am_mvec_diagR @(ku) @(nu) 1
      off += @(nu); if (off >= @(ku)) off -= @(ku);
      @iexp j 0
      @iwhile j < @(nu)
      A@(j) += incA;
         @iexp j @(j) 1 +
      @endiwhile
      j += @(nu);
         @iexp jn @(jn) @(nu) +
      @endiwhile
      @iif nr > 0
      /* now the last nu-panel (partial) */
         @iif nu < @(ku)
      for (i=0; i < (j-off); i++, b += @(incdup))
      {
         /* subblock copy */
         @callproc proc_cm2am_mvec_blk @(nr)
      }
      /* copy (off+@(nr))x@(nr) diag blk */
      @callproc proc_cm2am_mvec_diagR @(ku) @(nr) 1
         @endiif
         @iif nu } @(ku)
      for (i=0; i < j; i++, b += @(incdup))
      {
         /* subblock copy */
         @callproc proc_cm2am_mvec_blk @(nr)
      }
      /* copy @(nr)x@(nr) diag blk */
      @callproc proc_cm2am_mvec_diag @(nr) @(nr) 1
         @endiif
      @endiif
   #else
      /* if lower triangle, then diag block is the only block to copy */
      @iexp jn 0
      @iwhile jn < @(nn)
      @skip This section means nu < ku
      i = j - off;
      @iexp pn @(n) -@(jn) +
      /* copy @(pn)x@(nu) low-diag */
      @callproc proc_cm2am_mvec_diagR @(n) @(nu) 0
      off += @(nu); if (off >= @(ku)) off -= @(ku);
      @iexp j 0
      @iwhile j < @(nu)
      A@(j) += incA;
         @iexp j @(j) 1 +
      @endiwhile
      j += @(nu);
         @iexp jn @(jn) @(nu) +
      @endiwhile
      @iif nr > 0
      /* now copy @(nr)x@(nr) blk */
         @iif nu < @(ku)
      i = j - off;
      @callproc proc_cm2am_mvec_diagR @(n) @(nr) 0
         @endiif
         @iif nu } @(ku)
      i = j;
      @callproc proc_cm2am_mvec_diag @(nr) @(nr) 0
         @endiif
      @endiif
   #endif
      break;
   @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
   @endiif
}
@endiif
@skip /************************** BELOW ARE COMPLEX **********************/
@ROUT ATL_ccm2am ATL_crm2am 
   @ifdef ! dupB
      @define dupB @1@
   @endifdef
   @iif dupB = 0
      @undef dupB
      @define dupB @1@
   @endiif
   @iif dupB < 2
      @define dsuf @@
      @iexp incdup @(nu) 0 +
   @endiif
   @iif dupB > 1
      @define dsuf @d@(dupB)@
      @iexp incdup @(dupB) @(nu) *
   @endiif
   @define cnst @const @
   @define cnstb @@
@ROUT ATL_cam2cm ATL_cam2rm
   @define cnst @@
   @define cnstb @const @
@ROUT ATL_cam2cm ATL_ccm2am 
@iif kmaj = 1
   @iexp kmaj 0 0 +
@endiif
@iif kmaj ! 0
   @define ku @@(kmaj)@
@endiif
@ifdef ! ku
   @iif kmaj = 0
      @define ku @1@
   @endiif
@endifdef
@beginproc proc_ccm2am_elemR rA iA poff aoff
   @mif nalp ! "X
               @(rA)[@(poff)] = @(malp)pA[(@(aoff)) SHIFT];
               #ifdef Conj_
                  @(iA)[@(poff)] = @(calp)pA[((@(aoff)) SHIFT)+1];
               #else
                  @(iA)[@(poff)] = @(malp)pA[((@(aoff)) SHIFT)+1];
               #endif
   @endmif
   @mif nalp = "X
               rv = pA[(@(aoff)) SHIFT];
               #ifdef Conj_
                  iv = -pA[((@(aoff)) SHIFT)+1];
               #else
                  iv = pA[((@(aoff)) SHIFT)+1];
               #endif
               @(rA)[@(poff)] = rv*ra - iv*ia;
               @(iA)[@(poff)] = rv*ia + iv*ra;
   @endmif
@endproc
@beginproc proc_ccm2am_elem_U rA iA poff
   @mif nalp ! "X
               @(rA)[@(poff)] = @(malp)ATL_rone;
               @(iA)[@(poff)] = ATL_rzero;
   @endmif
   @mif nalp = "X
               @(rA)[@(poff)] = ra;
               @(iA)[@(poff)] = ia;
   @endmif
@endproc
@beginproc proc_ccm2am_elem poff ap aoff
   @mif nalp ! "X
               rA[@(poff)] = @(malp)A@(ap)[(@(aoff)) SHIFT];
               #ifdef Conj_
                  iA[@(poff)] = @(calp)A@(ap)[((@(aoff)) SHIFT)+1];
               #else
                  iA[@(poff)] = @(malp)A@(ap)[((@(aoff)) SHIFT)+1];
               #endif
   @endmif
   @mif nalp = "X
               rv = A@(ap)[(@(aoff)) SHIFT];
               #ifdef Conj_
                  iv = -A@(ap)[((@(aoff)) SHIFT)+1];
               #else
                  iv = A@(ap)[((@(aoff)) SHIFT)+1];
               #endif
               rA[@(poff)] = rv*ra - iv*ia;
               iA[@(poff)] = rv*ia + iv*ra;
   @endmif
@endproc
@beginproc proc_ccm2am_kvec_blk k n
   @iexp j 0
   @iwhile j < @(n)
      @iexp i 0
      @iwhile i < @(ku)
         @iexp ib @(j) @(ku) *
         @iexp ib @(ib) @(i) +
         @iif i < k
         @callproc proc_ccm2am_elem @(ib) @(j) i+@(i)
         @endiif
         @iif i } k
         rA[@(ib)] = iA[@(ib)] = ATL_rzero;
         @endiif
         @iexp i @(i) 1 +
      @endiwhile
      @iexp j @(j) 1 +
   @endiwhile
   @iwhile j < @(nu)
      @iexp i 0
      @iwhile i < @(ku)
         @iexp ib @(j) @(ku) *
         @iexp ib @(ib) @(i) +
         rA[@(ib)] = iA[@(ib)] = ATL_rzero;
         @iexp i @(i) 1 +
      @endiwhile
      @iexp j @(j) 1 +
   @endiwhile
@endproc
@beginproc proc_ccm2am_kvec_blkR
      if (Kr)
      {
         /* copy last partial non-diag block */
         for (k=0; k<Kr; k++)
         {
            @iexp j 0
            @iwhile j < @(nu)
               @iexp ib @(j) @(ku) *
                  @callproc proc_ccm2am_elem @(ib)+k @(j) i+k
               @iexp j @(j) 1 +
            @endiwhile
         }
         /* now pad if needed */
         for ( ; k<@(ku); k++)
         {
            @iexp j 0
            @iwhile j < @(nu)
               @iexp ib @(j) @(ku) *
            rA[@(ib)+k] = iA[@(ib)+k] = ATL_rzero;
               @iexp j @(j) 1 +
            @endiwhile
         }
         rA += @(binc); iA += @(binc);
      }
@endproc
@beginproc proc_ccm2am_kvec_diag1 bi isup
   @iif i < @(j)
      @iif isup = 1
         @callproc proc_ccm2am_elem @(bi) @(j) i+@(i)
      @endiif
      @iif isup = 0
         rA[@(bi)] = iA[@(bi)] = ATL_rzero;
      @endiif
   @endiif
   @iif i = @(j)
      #ifdef UnitDiag_
         @callproc proc_ccm2am_elem_U rA iA @(bi)
      #else
         @callproc proc_ccm2am_elem @(bi) @(j) i+@(i)
      #endif
   @endiif
   @iif i > @(j)
      @iif isup = 1
         rA[@(bi)] = iA[@(bi)] = ATL_rzero;
      @endiif
      @iif isup = 0
         @callproc proc_ccm2am_elem @(bi) @(j) i+@(i)
      @endiif
   @endiif
@endproc
@beginproc proc_ccm2am_kvec_diag k n isup
   @iif nu { @(ku)
   @iexp j 0
   @iwhile j < @(n)
      @iexp i 0
      @iwhile i < @(ku)
         @iexp ib @(j) @(ku) *
         @iexp ib @(ib) @(i) +
         @iif i < @(k)
            @callproc proc_ccm2am_kvec_diag1 @(ib) @(isup)
         @endiif
         @iif i } @(k)
            rA[@(ib)] = iA[@(ib)] = ATL_rzero;
         @endiif
         @iexp i @(i) 1 +
      @endiwhile
      @iexp j @(j) 1 +
   @endiwhile
   @iwhile j < @(nu)
      @iexp i 0
      @iwhile i < @(ku)
         @iexp ib @(j) @(ku) *
         @iexp ib @(ib) @(i) +
            rA[@(ib)] = iA[@(ib)] = ATL_rzero;
         @iexp i @(i) 1 +
      @endiwhile
      @iexp j @(j) 1 +
   @endiwhile
      rA += @(binc); iA += @(binc);
   @endiif
   @iif nu > @(ku)
      /* for nu > ku, use rolled loop for copying (nu x nu) diag-blk */
      {
      @iexp KK @(k) @(ku) +
      @iexp KK @(KK) -1 +
      @iexp KK @(ku) @(KK) /
      @iexp KK @(ku) @(KK) *
         int di, dj;
         const TYPE *pA = A0 + (i SHIFT);
         TYPE *pr, *pc;
         for (dj=0; dj<@(n); dj++, pA+=lda2)
         {
            pr = rA + dj*@(ku);
            pc = iA + dj*@(ku);
            int doff = 0;
            for (di=0; di<dj; di++)
            {
               @iif isup = 1 
               @callproc proc_ccm2am_elemR pr pc doff di
               @endiif
               @iif isup = 0 
               pr[doff] = pc[doff] = ATL_rzero;
               @endiif
               doff++;
               if (doff >= @(ku))
               {
                  doff = 0;
                  pr += @(binc);
                  pc += @(binc);
               }
            }
            /* now the diagonal element */
            #ifdef UnitDiag_
               @callproc proc_ccm2am_elem_U pr pc doff
            #else
               @callproc proc_ccm2am_elemR pr pc doff di
            #endif
            doff++;
            if (doff >= @(ku))
            {
               doff = 0;
               pr += @(binc);
               pc += @(binc);
            }
            di++;
            /* now below-diag elems */
            for ( ; di<@(k); di++)
            {
               @iif isup = 1 
               pr[doff] = pc[doff] = ATL_rzero;
               @endiif
               @iif isup = 0 
               @callproc proc_ccm2am_elemR pr pc doff di
               @endiif
               doff++;
               if (doff >= @(ku))
               {
                  doff = 0;
                  pr += @(binc);
                  pc += @(binc);
               }
            }
            @iif k < @(KK)
            /* now below-diag padding */
            for ( ; di<@(KK); di++)
            {
               pr[doff] = pc[doff] = ATL_rzero;
               doff++;
               if (doff >= @(ku))
               {
                  doff = 0;
                  pr += @(binc);
                  pc += @(binc);
               }
            }
            @endiif
         }
         @iif n < @(nu)
         for ( ; dj<@(nu); dj++)
         {
            pr = rA + dj*@(ku);
            pc = iA + dj*@(ku);
            int doff = 0;
            for (di=0; di<@(KK); di++)
            {
               pr[doff] = pc[doff] = ATL_rzero;
               doff++;
               if (doff >= @(ku))
               {
                  doff = 0;
                  pr += @(binc);
                  pc += @(binc);
               }
            }
         }
         @endiif
         rA += @(nu)*@(nu); iA += @(nu)*@(nu);
      }
   @endiif
@endproc
@beginproc proc_ccm2am_kvec_diagR k n isup
      {
         int di, dj;
         const TYPE *pA = A0 + (i SHIFT);
         /* now copy the diag part */
         for (dj=0; dj<@(n); dj++, pA+=lda2)
         {
            int dbound = off + dj;
            for (di=0; di<dbound; di++)
            {
            @iif isup = 1 
               @callproc proc_ccm2am_elemR rA iA dj*@(ku)+di di
            @endiif
            @iif isup = 0 
               rA[dj*@(ku)+di] = iA[dj*@(ku)+di] = ATL_rzero;
            @endiif
            }
            /* now the diagonal element */
            #ifdef UnitDiag_
               @callproc proc_ccm2am_elem_U rA iA dj*@(ku)+di
            #else
               @callproc proc_ccm2am_elemR rA iA dj*@(ku)+di di
            #endif
            for (di++; di<@(k); di++)
            {
            @iif isup = 1 
               rA[dj*@(ku)+di] = iA[dj*@(ku)+di] = ATL_rzero;
            @endiif
            @iif isup = 0 
               @callproc proc_ccm2am_elemR rA iA dj*@(ku)+di di
            @endiif
            }
            @iif isup = 0 
               @iif k < @(ku)
               for ( ; di<@(ku); di++)
                  rA[dj*@(ku)+di] = iA[dj*@(ku)+di] = ATL_rzero;
               @endiif
            @endiif
         }
         @iif n < @(nu)
         /* now nu-padding */
         for ( ; dj<@(nu); dj++)
            for (di=0; di<@(ku); di++)
               rA[dj*@(ku)+di] = iA[dj*@(ku)+di] = ATL_rzero;
         @endiif
         rA += @(binc); iA += @(binc);
      }
@endproc
@iif kmaj ! 0
   @iexp ku2 @(ku) @(ku) +
@ROUT ATL_cam2cm
void ATL_USERCPMM
(
   ATL_CSZT K,          /* number of rows in A */
   const SCALAR alpha,  /* scalar for rA,iA */
   const TYPE *rA,      /* access-ku-major block holding real(A) */
   const TYPE *iA,      /* access-ku-major block holding imag(A) */
   TYPE *A,             /* OUTPUT: submatrix to copy rA/iA to */
   ATL_CSZT lda         /* stride between row elements */
)
@ROUT ATL_ccm2am 
/*
 * This routine copies the KxK triangular submatrix A into 
 * access-k-vlen-major storage.
 * In this storage, @(nu) vectors of @(ku) length are taken from the
 * @(nu) columns of A and stored in a @(ku)x@(nu) subblock.
 * CEIL(K/ku) of these subblocks are stored together to make a K-panel.
 * The CEIL(K/nu) K-panels are stored contiguously.  If ku does not evenly
 * divide K then the last block in the K-panel will be zero padded, and
 * the same is true for the NU portion of the every K-panel since only 1 in 
 * each nu-sized panels evenly divides N.
 */
void ATL_USERCPMM
(
   ATL_CSZT K,          /* number of rows in A */
   const SCALAR alpha,  /* scalar for A */
   const TYPE *A,       /* matrix to be copied to access-major format */
   ATL_CSZT lda,        /* stride between row elements */
   TYPE *rA,            /* OUTPUT: access-ku-major block holding real(A) */
   TYPE *iA             /* OUTPUT: access-ku-major block holding imag(A) */
)
@ROUT ATL_cam2cm ATL_ccm2am 
{
   @iif nu } @(ku)
      @iexp koff @(nu)
   @endiif
   @iif nu < @(ku)
      @iexp koff @(ku)
   ATL_INT off = 0;
   @endiif
   ATL_CSZT n = (K/@(koff))*@(koff), nr=K-n;
   ATL_CSZT Kr = K - (K/@(ku))*@(ku);
   ATL_CSZT lda2 = lda+lda, incA = lda2*@(nu);
   ATL_SZT i, j, k;
   @mif nalp = "X
   const register TYPE ra=(*alpha), ia=alpha[1];
   register TYPE rv, iv;
   @endmif
   @declare "   @(cnst)TYPE " n n ";"
      *A0=A
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *A@(j)=A@(i)+lda2
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
   @iexp binc @(nu) @(ku) *

   for (j=0; j < n; j += @(nu))
   {
   #ifdef Upper_
         @iif nu < @(ku)
      for (i=0; i < (j-off); i += @(ku), rA += @(binc), iA += @(binc))
      {
         /* subblock copy */
         @callproc proc_ccm2am_kvec_blk @(ku) @(nu)
      }
      /* copy (off+@(nu))x@(nu) diag block */
      @callproc proc_ccm2am_kvec_diagR @(ku) @(nu) 1
      off += @(nu); if (off >= @(ku)) off -= @(ku);
         @endiif
         @iif nu } @(ku)
      for (i=0; i < j; i += @(ku), rA += @(binc), iA += @(binc))
      {
         /* subblock copy */
         @callproc proc_ccm2am_kvec_blk @(ku) @(nu)
      }
      /* copy @(nu)x@(nu) diag block */
      @callproc proc_ccm2am_kvec_diag @(nu) @(nu) 1
         @endiif
   #else
      /* copy @(koff)x@(nu) diag block */
         @iif nu < @(ku)
      i = j - off;
      @callproc proc_ccm2am_kvec_diagR @(ku) @(nu) 0
      off += @(nu); if (off >= @(ku)) off -= @(ku);
         @endiif
         @iif nu } @(ku)
      i = j;
      @callproc proc_ccm2am_kvec_diag @(nu) @(nu) 0
         @endiif

      for (i+=@(koff); i < (K-Kr); i += @(ku), rA += @(binc), iA += @(binc))
      {
         /* subblock copy */
         @callproc proc_ccm2am_kvec_blk @(ku) @(nu)
      }
      @callproc proc_ccm2am_kvec_blkR
   #endif
      @iexp j 0 0 +
      @iwhile j < @(nu)
      A@(j) += incA;
         @iexp j @(j) 1 +
      @endiwhile
   }
   @iif koff ! 1
   switch(nr)
   {
   @iexp n 1 0 +
   @iwhile n < @(koff)
   case @(n): /* If nu < ku: may require multiple panel */
   @iexp nn @(nu) @(nu) @(n) / *
   @iexp nr @(n) -@(nn) +
   #ifdef Upper_
      @iexp jn 0
      @iwhile jn < @(nn)
      @skip this section means nu < ku
      for (i=0; i < (j-off); i += @(ku), rA += @(binc), iA += @(binc))
      {
         /* subblock copy */
         @callproc proc_ccm2am_kvec_blk @(ku) @(nu)
      }
      /* copy (off+@(nu))x@(nu) diag blk */
      @callproc proc_ccm2am_kvec_diagR @(ku) @(nu) 1
      off += @(nu); if (off >= @(ku)) off -= @(ku);
      @iexp j 0
      @iwhile j < @(nu)
      A@(j) += incA;
         @iexp j @(j) 1 +
      @endiwhile
      j += @(nu);
         @iexp jn @(jn) @(nu) +
      @endiwhile
      @iif nr > 0
      /* now the last nu-panel (partial) */
         @iif nu < @(ku)
      for (i=0; i < (j-off); i += @(ku), rA += @(binc), iA += @(binc))
      {
         /* subblock copy */
         @callproc proc_ccm2am_kvec_blk @(ku) @(nr)
      }
      /* copy (off+@(nr))x@(nr) block */
      @callproc proc_ccm2am_kvec_diagR @(ku) @(nr) 1
         @endiif
         @iif nu } @(ku)
      for (i=0; i < j; i += @(ku), rA += @(binc), iA += @(binc))
      {
         /* subblock copy */
         @callproc proc_ccm2am_kvec_blk @(ku) @(nr)
      }
      /* copy @(nr)x@(nr) block */
      @callproc proc_ccm2am_kvec_diag @(nr) @(nr) 1
         @endiif
      @endiif
   #else
      /* if lower triangle, then diag block is the only block to copy */
      @iexp jn 0
      @iwhile jn < @(nn)
         @skip this section means nu < ku
      i = j - off;
         @iexp pn @(n) -@(jn) +
      /* copy @(pn)x@(nu) low-diag */
      @callproc proc_ccm2am_kvec_diagR @(n) @(nu) 0 /* TODO: should it be pn? */
      off += @(nu); if (off >= @(ku)) off -= @(ku);
         @iexp j 0
         @iwhile j < @(nu)
      A@(j) += incA;
            @iexp j @(j) 1 +
         @endiwhile
      j += @(nu);
         @iexp jn @(jn) @(nu) +
      @endiwhile
      @iif nr > 0
      /* now copy @(nr)x@(nr) block */
         @iif nu < @(ku)
      i = j - off;
      @callproc proc_ccm2am_kvec_diagR @(n) @(nr) 0
         @endiif
         @iif nu } @(ku)
      i = j;
      @callproc proc_ccm2am_kvec_diag @(nr) @(nr) 0
         @endiif
      @endiif
   #endif
      break;
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
   @endiif
}
@endiif
@beginproc proc_ccm2am_mvec_blk n
   @iexp j 0
   @iwhile j < @(n)
      @callproc proc_ccm2am_elem @(j) @(j) i
      @iexp j @(j) 1 +
   @endiwhile
@ROUT ATL_ccm2am 
   @iwhile j < @(nu)
         rA[@(j)] = iA[@(j)] = ATL_rzero;
      @iexp j @(j) 1 +
   @endiwhile
@ROUT ATL_cam2cm ATL_ccm2am 
@endproc
@beginproc proc_ccm2am_mvec_KPAD
   @iif ku > 1
      if (Kr)
      {
@ROUT ATL_ccm2am 
         /* pad @(ku)-Kr rows */
         for (k=0; k < (@(ku)-Kr); k++, rA += @(incdup), iA += @(incdup))
         {
      @iexp j 0
      @iwhile j < @(nu)
            rA[@(j)] = iA[@(j)] = 
         @iexp j @(j) 1 +
      @endiwhile
                  ATL_rzero;
         }
@ROUT ATL_am2cm ATL_ccm2am 
      }
   @endiif
@endproc
@beginproc proc_ccm2am_diag1 bi isup
   @iif i < @(j)
         @iif isup = 1
            @callproc proc_ccm2am_elem @(bi) @(j) i+@(i)
         @endiif
         @iif isup = 0
            rA[@(bi)] = iA[@(bi)] = ATL_rzero;
         @endiif
   @endiif
   @iif i = @(j)
         #ifdef UnitDiag_
            @callproc proc_ccm2am_elem_U rA iA @(bi)
         #else
            @callproc proc_ccm2am_elem @(bi) @(j) i+@(i)
         #endif
   @endiif
   @iif i > @(j)
         @iif isup = 1
            rA[@(bi)] = iA[@(bi)] = ATL_rzero;
         @endiif
         @iif isup = 0
            @callproc proc_ccm2am_elem @(bi) @(j) i+@(i)
         @endiif
   @endiif
@endproc
@beginproc proc_ccm2am_mvec_diag k n isup
   @iexp i 0
   @iwhile i < @(k)
      @iexp j 0
      @iwhile j < @(n)
         @callproc proc_ccm2am_diag1 @(j) @(isup)
         @iexp j @(j) 1 +
      @endiwhile
@ROUT ATL_ccm2am 
      @iwhile j < @(nu)
      rA[@(j)] = iA[@(j)] = ATL_rzero;
         @iexp j @(j) 1 +
      @endiwhile
@ROUT ATL_cam2cm ATL_ccm2am 
      rA += @(incdup); iA += @(incdup);
      @iexp i @(i) 1 +
   @endiwhile
   @iif ku > 1
   @skip KK = ((n+ku-1) / ku) * ku
   @iexp KK @(ku) @(ku) 1 @(ku) - @(n) + / *
   @skip ZSKIP = (KK - n)*incdup
   @iexp ZSKIP @(n) @(KK) - @(incdup) *
@ROUT ATL_cam2cm
      rA += @(ZSKIP); iA += @(ZSKIP);
@ROUT ATL_ccm2am 
   @iwhile i < @(KK)
      /* needs KU-padding */
      @iexp j 0
      @iwhile j < @(nu)
      rA[@(j)] = iA[@(j)] = ATL_rzero;
         @iexp j @(j) 1 +
      @endiwhile
      rA += @(incdup); iA += @(incdup);
      @iexp i @(i) 1 +
   @endiwhile
@ROUT ATL_cam2cm ATL_ccm2am 
   @endiif
@endproc
@beginproc proc_ccm2am_mvec_diagR k n isup
      {
         int di, dj;
         const TYPE *pA = A0 + (i SHIFT);
         /* now copy the diag part */
         for (dj=0; dj<@(n); dj++, pA+=lda2)
         {
            int dbound = off + dj;
            for (di=0; di<dbound; di++)
            {
            @iif isup = 1
               @callproc proc_ccm2am_elemR rA iA di*@(nu)+dj di
            @endiif            
            @iif isup = 0
               rA[di*@(nu)+dj] = iA[di*@(nu)+dj] = ATL_rzero;
            @endiif            
            }
            /* now the diagonal element */
            #ifdef UnitDiag_
               @callproc proc_ccm2am_elem_U rA iA di*@(nu)+dj
            #else
               @callproc proc_ccm2am_elemR rA iA di*@(nu)+dj di
            #endif
            for (di++; di<@(k); di++)
            {
            @iif isup = 1
               rA[di*@(nu)+dj] = iA[di*@(nu)+dj] = ATL_rzero;
            @endiif            
            @iif isup = 0
               @callproc proc_ccm2am_elemR rA iA di*@(nu)+dj di
            @endiif            
            }
            @iif isup = 0
               @iif k < @(ku)
            /* bottom padding */
               for (; di<@(ku); di++)
                  rA[di*@(nu)+dj] = iA[di*@(nu)+dj] = ATL_rzero;
               @endiif
            @endiif            
         }
         @iif n < @(nu)
         /* now nu-padding */
         for (di=0; di<@(ku); di++)
            for (dj=@(n); dj<@(nu); dj++)
               rA[di*@(nu)+dj] = iA[di*@(nu)+dj] = ATL_rzero;
         @endiif
         rA += @(incdup)*@(ku); iA += @(incdup)*@(ku);
      }
@endproc
@iif kmaj = 0
@ROUT ATL_cam2cm
/*
 * Copies from (M-vectorized) access-major storage triangular block b back 
 * to column-major storage A, with possible scale.
 * For TRMM, this routine handles Notrans B matrices, and Trans A matrices.
 */
void ATL_USERCPMM       /* col-major matx to access-major blk */
(
   ATL_CSZT K,          /* number of rows in A */
   const SCALAR alpha,  /* scalar for A */
   const TYPE *rA,      /* access-major block holding real(A) */
   const TYPE *iA,      /* access-major block holding imag(A) */
   TYPE *A,             /* OUTPUT: submatrix to cpy access-major blk */
   ATL_CSZT lda         /* stride between row elements */
)
@ROUT ATL_ccm2am 
/*
 * This routine copies the KxK triangular submatrix A into 
 * the CEIL(K/@(ku))xCEIL(K/@(mu)) block b.
 * In this storage, @(nu) vectors of @(ku) length are taken from the
 * @(nu) columns of A and stored in a @(ku)x@(nu) subblock.
 * CEIL(K/ku) of these subblocks are stored together to make a K-panel.
 * The CEIL(K/nu) K-panels are stored contiguously.  If ku does not evenly
 * divide K then the last block in the K-panel will be zero padded, and
 * similarly pad the last nu-panel if its size is less than @(nu).
 * For TRMM, this routine handles Notrans B matrices, and Trans A matrices.
 */
void ATL_USERCPMM       /* col-major matx to access-major blk */
(
   ATL_CSZT K,          /* number of rows/cols in A */
   const SCALAR alpha,  /* scalar for A */
   const TYPE *A,       /* matrix to be copied to access-major format */
   ATL_CSZT lda,        /* stride between row elements */
   TYPE *rA,            /* OUTPUT: access-major block holding real(A) */
   TYPE *iA             /* OUTPUT: access-major block holding imag(A) */
)
@ROUT ATL_cam2cm ATL_ccm2am 
{
   @iif nu } @(ku)
      @iexp koff @(nu)
   @endiif
   @iif nu < @(ku)
      @iexp koff @(ku)
   ATL_INT off = 0;
   @endiif
   ATL_CSZT n = (K/@(koff))*@(koff), nr = K-n;
   ATL_CSZT lda2 = lda+lda, incA = lda2*@(nu);
   @iif ku > 1
   ATL_CSZT Kr = K - (K/@(ku))*@(ku);
@skip @ROUT ATL_cam2cm  `   ATL_CINT ZINC = KR*@(nu)`
   @endiif
   ATL_SZT i, j, k;
   @mif nalp = "X
   const register TYPE ra=(*alpha), ia=alpha[1];
   register TYPE rv, iv;
   @endmif
   @iexp incb @(ku) @(nu) *

   @declare "   @(cnst)TYPE " n n ";"
      *A0=A
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *A@(j)=A@(i)+lda2
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare

   for (j=0; j < n; j += @(nu))
   {
   #ifdef Upper_
         @iif nu < @(ku)
      for (i=0; i < (j-off); i++, rA += @(incdup), iA += @(incdup))
      {
         /* subblock copy */
         @callproc proc_ccm2am_mvec_blk @(nu)
      }
      /* copy (off+@(nu))x@(nu) diag block */
      @callproc proc_ccm2am_mvec_diagR @(ku) @(nu) 1
      off += @(nu); if (off >= @(ku)) off -= @(ku);
         @endiif
         @iif nu } @(ku)
      for (i=0; i < j; i++, rA += @(incdup), iA += @(incdup))
      {
         /* subblock copy */
         @callproc proc_ccm2am_mvec_blk @(nu)
      }
      /* copy @(nu)x@(nu) diag block */
      @callproc proc_ccm2am_mvec_diag @(nu) @(nu) 1
         @endiif
   #else
      /* copy @(koff)x@(nu) diag block */
         @iif nu < @(ku)
      i = j - off;
      @callproc proc_ccm2am_mvec_diagR @(ku) @(nu) 0
      off += @(nu); if (off >= @(ku)) off -= @(ku);
         @endiif
         @iif nu } @(ku)
      i = j;
      @callproc proc_ccm2am_mvec_diag @(nu) @(nu) 0
         @endiif

      for (i+=@(koff); i < K; i++, rA += @(incdup), iA += @(incdup))
      {
         /* subblock copy */
         @callproc proc_ccm2am_mvec_blk @(nu)
      }
      @callproc proc_ccm2am_mvec_KPAD
   #endif
      @iexp j 0 
      @iwhile j < @(nu)
      A@(j) += incA;
         @iexp j @(j) 1 +
      @endiwhile
   }
   @iif koff ! 1
   switch(nr)
   {
   @iexp n 1 0 +
   @iwhile n < @(koff)
   case @(n): /* If nu < ku: may require multiple panel */
   @iexp nn @(nu) @(nu) @(n) / *
   @iexp nr @(n) -@(nn) +
   #ifdef Upper_
      @iexp jn 0
      @iwhile jn < @(nn)
      @skip This section means nu < ku.
      for (i=0; i < (j-off); i++, rA += @(incdup), iA += @(incdup))
      {
         /* subblock copy */
         @callproc proc_ccm2am_mvec_blk @(nu)
      }
      /* copy (off+@(nu))x@(nu) diag block */
      @callproc proc_ccm2am_mvec_diagR @(ku) @(nu) 1
      off += @(nu); if (off >= @(ku)) off -= @(ku);
      @iexp j 0
      @iwhile j < @(nu)
      A@(j) += incA;
         @iexp j @(j) 1 +
      @endiwhile
      j += @(nu);
         @iexp jn @(jn) @(nu) +
      @endiwhile
      @iif nr > 0
      /* now the last nu-panel (partial) */
         @iif nu < @(ku)
      for (i=0; i < (j-off); i++, rA += @(incdup), iA += @(incdup))
      {
         /* subblock copy */
         @callproc proc_ccm2am_mvec_blk @(nr)
      }
      /* copy (off+@(nr))x@(nr) diag block */
      @callproc proc_ccm2am_mvec_diagR @(ku) @(nr) 1
         @endiif
         @iif nu } @(ku)
      for (i=0; i < j; i++, rA += @(incdup), iA += @(incdup))
      {
         /*subblock copy */
         @callproc proc_ccm2am_mvec_blk @(nr)
      }
      /* copy @(nr)x@(nr) diag blk */
      @callproc proc_ccm2am_mvec_diag @(nr) @(nr) 1
         @endiif
      @endiif
   #else
      /* if lower triangle, then diag block is the only block to copy */
      @iexp jn 0
      @iwhile jn < @(nn)
      @skip This section means nu < ku
      i = j - off;
      @iexp pn @(n) -@(jn) +
      /* copy @(pn)x@(nu) low-diag */
      @callproc proc_ccm2am_mvec_diagR @(n) @(nu) 0
      off += @(nu); if (off >= @(ku)) off -= @(ku);
      @iexp j 0
      @iwhile j < @(nu)
      A@(j) += incA;
         @iexp j @(j) 1 +
      @endiwhile
      j += @(nu);
         @iexp jn @(jn) @(nu) +
      @endiwhile
      @iif nr > 0
      /* now copy @(nr)x@(nr) blk */
         @iif nu < @(ku)
      i = j - off;
      @callproc proc_ccm2am_mvec_diagR @(n) @(nr) 0
         @endiif
         @iif nu } @(ku)
      i = j;
      @callproc proc_ccm2am_mvec_diag @(nr) @(nr) 0
         @endiif
      @endiif
   #endif
      break;
   @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
   @endiif
}
@endiif
@ROUT ATL_am2rm ATL_rm2am 
@beginproc proc_rm2am_kvec_zero m
@ROUT ATL_rm2am 
      @iexp i 0 0 +
      @iwhile i < @(m)
         @iexp ip @(i) @(ku) *
         pp[@(ip)] = ATL_rzero;
      @iexp i @(i) 1 +
      @endiwhile
@ROUT ATL_am2rm ATL_rm2am 
@endproc
@beginproc proc_rm2am_kvec_blk m
      @iexp i 0 0 +
      @iwhile i < @(m)
         @iexp ip @(i) @(ku) *
   @ROUT ATL_am2rm
            A[@(i)] = @(malp)pp[@(ip)];
   @ROUT ATL_rm2am 
            pp[@(ip)] = @(malp)A[@(i)];
   @ROUT ATL_am2rm ATL_rm2am 
         @iexp i @(i) 1 +
      @endiwhile
@ROUT ATL_rm2am 
      @iwhile i < @(mu)
         @iexp ip @(i) @(ku) *
            pp[@(ip)] = ATL_rzero;
         @iexp i @(i) 1 +
      @endiwhile
@ROUT ATL_am2rm ATL_rm2am 
@endproc
@iif kmaj ! 0
   @define ku @@(kmaj)@
@ROUT ATL_am2rm
void ATL_USERCPMM       /* access-major blk to row-major matrix */
(
   ATL_CSZT K,          /* number of rows/cols in A */
   const SCALAR alpha,  /* scalar for b */
   const TYPE *b,       /* INPUT: access-major block to copy to A */
   TYPE *A,             /* OUTPUT: matrix copied from access-major block */
   ATL_CSZT lda         /* stride between row elements */
)
@ROUT ATL_rm2am 
/*
 * This routine copies the KxK triangular submatrix A into 
 * access-k-vlen-major storage b.
 * In this storage, @(mu) vectors of @(ku) length are taken from the
 * @(mu) rows of A and stored in a @(ku)x@(mu) subblock.
 * CEIL(K/ku) of these subblocks are stored together to make a K-panel.
 * The CEIL(K/mu) K-panels are stored contiguously.  If ku does not evenly
 * divide K then subblocks in K-panels will be zero padded, and
 * similarly pad the last mu-panel if its size is less than @(mu).
 * For GEMM, this routine handles Notrans A matrices, and Trans B matrices.
 */
void ATL_USERCPMM       /* row-major matrix to access-major block */
(
   ATL_CSZT K,          /* number of rows/cols in triangular A */
   const SCALAR alpha,  /* scalar for A */
   const TYPE *A,       /* matrix to be copied to access-major format */
   ATL_CSZT lda,        /* stride between row elements */
   TYPE *b              /* OUTPUT: access-major block holding condensed A */
)
@ROUT ATL_am2rm ATL_rm2am 
{
   @iif mu } @(ku)
      @iexp koff @(mu)
   @endiif
   @iif mu < @(ku)
      @iexp koff @(ku)
   @endiif
   ATL_CSZT m = (K/@(mu))*@(mu), mr = K-m, incA = lda - m;
   ATL_CSZT KK = ((K+@(ku)-1)/@(ku))*@(ku);
   int i, j, k, pi;
   @iif mu > @(ku)
   int pj=0, joff=0;
   @endiif
   @iexp incb @(ku) @(mu) *

   int off=0, coff=0;
   #ifdef Upper_
   for (j=0; j<K; j++, b++, A+=(lda-j))
   {
      @(cnstb)TYPE *pp = b;  /* panel ptr */
      int poff = KK, ioff = 0;
      @iif mu < @(ku)
      for (i=0; i<(j-@(mu)+1); i+=@(mu), A+=@(mu))
      @endiif
      @iif mu } @(ku)
      for (i=0; i<(j-coff); i+=@(mu), A+=@(mu))
      @endiif
      {
         @callproc proc_rm2am_kvec_blk @(mu)
      @iif mu < @(ku)
         ioff += @(mu); if (ioff >= @(ku)) { ioff = 0; poff -= @(ku); }
      @endiif
      @iif mu } @(ku)
         poff -= @(mu);
      @endiif
         pp += poff*@(mu);
      }
      /* now copy the diag part */
      for (pi=0; i<j; i++, pi++, A++)
         pp[pi*@(ku)] = @(malp)(*A);
      /* diag elem */
      #ifdef UnitDiag_
         pp[pi*@(ku)] = @(malp)ATL_rone;
      #else
         pp[pi*@(ku)] = @(malp)(*A);
      #endif
      for (i++, A++, pi++ ; pi<@(mu); i++, pi++)
         pp[pi*@(ku)] = ATL_rzero;
      @iif mu < @(ku)
      pp += poff*@(mu);
      for (pi=coff+@(mu); pi<@(ku) && i<K; pi+=@(mu), i+=@(mu))
      {
         @callproc proc_rm2am_kvec_zero @(mu)
         pp += poff*@(mu);
      }
      @endiif
      @iif mu > @(ku)
      joff++;
      if (joff >= @(ku))
      {
         joff = 0;
         b += @(mu)*@(ku) - @(ku);
      }
      @endiif
      coff++;
      if (coff >= @(koff))
      {
         coff = 0; off += @(koff); 
         @iif mu { @(ku)
         b += @(koff)*@(mu)- @(koff);
         @endiif
      }
   }
@ROUT ATL_rm2am 
   @iif ku > 1
   for (; j<KK; j++, b++)
   {
      @(cnstb)TYPE *pp = b;  /* panel ptr */
      int poff = KK, ioff = 0;
      for (i=0; i<Mmin(j,K); i+=@(mu))
      {
         @callproc proc_rm2am_kvec_zero @(mu)
      @iif mu < @(ku)
         ioff += @(mu); if (ioff >= @(ku)) { ioff = 0; poff -= @(ku); }
      @endiif
      @iif mu } @(ku)
         poff -= @(mu);
      @endiif
         pp += poff*@(mu);
      }
   }
   @endiif
@ROUT ATL_am2rm ATL_rm2am 
   @skip @endmif
   #else
   for (j=0; j < m; j++, A+=incA)
   {
      @(cnstb)TYPE *pp = b+coff;  /* panel ptr */
      int poff = off, iz = coff;
      @iif mu < @(ku)
      int zpi, ioff = 0;
      /* initial zero padding if needed */
      for (zpi=@(mu); zpi<=coff; zpi+=@(mu), iz-=@(mu))
      {
         @callproc proc_rm2am_kvec_zero @(mu)
         pp += (poff+@(ku))*@(mu);
         ioff += @(mu); if (ioff  >= @(ku)) { ioff = 0; poff+=@(ku); }
      }
      @endiif
      @iif mu > @(ku)
      pp += pj;
      @endiif
      i = j;
      A = A+i;
      /* copy diag block */
      for (pi=0; pi < iz; pi++)
         pp[pi*@(ku)] = ATL_rzero;
      #ifdef UnitDiag_
         pp[pi*@(ku)] = @(malp)ATL_rone;
      #else
         pp[pi*@(ku)] = @(malp)(*A);
      #endif
      for (A++, pi++, i++; pi<@(mu); A++, pi++, i++)
         pp[pi*@(ku)] = @(malp)(*A);
      pp += (poff+@(koff))*@(mu);
      @iif mu < @(ku)
      ioff += @(mu); if (ioff  >= @(ku)) { ioff = 0; poff+=@(ku); }
      @endiif
      @iif mu } @(ku)
      poff += @(koff);
      @endiif
      for (; i<m; i+=@(mu), A+=@(mu))
      {
         @callproc proc_rm2am_kvec_blk @(mu)
         pp += (poff+@(koff))*@(mu);
      @iif mu < @(ku)
         ioff += @(mu); if (ioff  >= @(ku)) { ioff = 0; poff+=@(ku); }
      @endiif
      @iif mu } @(ku)
         poff += @(koff);
      @endiif
      }
      @iif mu > 1
      switch(mr)
      {
      @iexp n 1 0 +
      @iwhile n < @(mu)
      case @(n):
         @callproc proc_rm2am_kvec_blk @(n)
         break;
      @iexp n @(n) 1 +
      @endiwhile
      default:;
      }
      @endiif
      @iif mu > @(ku)
      joff++;
      if (joff >= @(ku))
      {
         joff = 0;
         pj += @(mu)*@(ku) - @(ku);
      }
      @endiif
      coff++; 
      if (coff >= @(koff))
      { 
         coff = 0; off += @(koff);
         b += (off+@(mu))*@(koff);
      @iif mu > @(ku)
         pj = 0;
      @endiif
      }
   }
   @iif mu > 1
   if (mr)  /* need zero padding */
   {
      for (; j<K; j++, A += (lda-K))
      {
         @(cnstb)TYPE *pp = b+coff;  /* panel ptr */
         int poff = off, iz = coff;
         @iif mu < @(ku)
         int zpi, ioff = 0;
         /* initial zero padding if needed */
         for (zpi=@(mu); zpi<=coff; zpi+=@(mu), iz-=@(mu))
         {
            @callproc proc_rm2am_kvec_zero @(mu)
            pp += (poff+@(ku))*@(mu);
            ioff += @(mu); if (ioff  >= @(ku)) { ioff = 0; poff+=@(ku); }
         }
         @endiif
         @iif mu > @(ku)
         pp += pj;
         @endiif
         i = j;
         A = A+i;
         /* copy diag block */
         for (pi=0; pi<iz; pi++)
            pp[pi*@(ku)] = ATL_rzero;
         #ifdef UnitDiag_
            pp[pi*@(ku)] = @(malp)ATL_rone;
         #else
            pp[pi*@(ku)] = @(malp)(*A);
         #endif
         for (A++, pi++; pi<mr; A++, pi++)
            pp[pi*@(ku)] = @(malp)(*A);
         for ( ; pi<@(mu); pi++)
            pp[pi*@(ku)] = ATL_rzero;
         @iif mu > @(ku)
         joff++;
         if (joff >= @(ku))
         {
            joff = 0;
            pj += @(mu)*@(ku) - @(ku);
         }
         @endiif
         coff++;
         if (coff >= @(koff))
         {
            coff = 0; off += @(koff);
            b += (off+@(mu))*@(koff);
         @iif mu > @(ku)
            pj = 0;
         @endiif
         }
      }
   }
   @endiif
@ROUT ATL_rm2am 
   @iif ku > 1
   i = coff;
   for ( ; j<KK; j++) /* ku-padding */
   {
      @(cnstb)TYPE *pp = b+coff;  /* panel ptr */
      int poff = off;
      @iif mu < @(ku)
      int zpi, ioff = 0;
      /* initial zero padding if needed */
      for (zpi=0; zpi<i; zpi+=@(mu))
      {
         @callproc proc_rm2am_kvec_zero @(mu)
         pp += (poff+@(ku))*@(mu);
         ioff += @(mu); if (ioff  >= @(ku)) { ioff = 0; poff+=@(ku); }
      }
      @endiif
      @iif mu > @(ku)
      pp += pj;
      @endiif
      @iif mu } @(ku)
         @callproc proc_rm2am_kvec_zero @(mu)
      @endiif
      @iif mu > @(ku)
      joff++;
      if (joff >= @(ku))
      {
         joff = 0;
         pj += @(mu)*@(ku) - @(ku);
      }
      @endiif
      coff++;
      if (coff >= @(koff))
      {
         coff = 0; off += @(koff);
         b += (off+@(mu))*@(koff);
      }
   }
   @endiif
   @skip @endmif
   #endif
@ROUT ATL_am2rm ATL_rm2am 
}
@endiif
@ROUT ATL_am2rm ATL_rm2am 
@beginproc proc_rm2am_mvec_zero m
@ROUT ATL_rm2am 
      @iexp i 0 0 +
      @iwhile i < @(m)
         @iexp ik @(dupB) @(i) *
         @iexp k @(dupB) -1 +
         @iwhile k > 0
         pp[@(ik)+@(k)] =
            @iexp k @(k) -1 +
         @endiwhile
         pp[@(ik)] = ATL_rzero;
      @iexp i @(i) 1 +
      @endiwhile
@ROUT ATL_am2rm ATL_rm2am 
@endproc
@beginproc proc_rm2am_mvec_blk m
      @iexp i 0 0 +
      @iwhile i < @(m)
         @iexp ik @(dupB) @(i) *
@ROUT ATL_rm2am 
         @iexp k @(dupB) -1 +
         @iwhile k > 0
         pp[@(ik)+@(k)] =
            @iexp k @(k) -1 +
         @endiwhile
         pp[@(ik)] = @(malp)A[@(i)];
@ROUT ATL_am2rm
         A[@(i)] = @(malp)pp[@(ik)];
@ROUT ATL_am2rm ATL_rm2am 
      @iexp i @(i) 1 +
      @endiwhile
@ROUT ATL_rm2am 
         @iwhile i < @(mu)
            @iexp ik @(dupB) @(i) *
            @iexp k @(dupB) -1 +
            @iwhile k > 0
         pp[@(ik)+@(k)] =
               @iexp k @(k) -1 +
            @endiwhile
         pp[@(ik)] = ATL_rzero;
         @iexp i @(i) 1 +
         @endiwhile
@ROUT ATL_am2rm ATL_rm2am 
@endproc
@iif kmaj = 0
@ROUT ATL_am2rm
/*
 * Copies from (M-vectorized) access-major storage triangular block b back
 * to column-major storage A, with possible scale. 
 * This routine handles Trans B matrices and NoTrans A matrices. 
 */
void ATL_USERCPMM       /* access-major blk to row-major submatrix */
(
   ATL_CSZT K,          /* number of rows/cols in triangular A */
   const SCALAR alpha,  /* scalar for b */
   const TYPE *b,       /* INPUT: access-major block holding A */
   TYPE *A,             /* OUTPUT: submatrix copied frm access-major b */
   ATL_CSZT lda         /* stride between row elements */
)
@ROUT ATL_rm2am 
/*
 * This routine copies the KxK triangular submatrix A into 
 * the CEIL(K/@(ku))xCEIL(K/@(mu)) block b.
 * In this storage, @(mu) vectors of @(ku) length are taken from the
 * @(mu) rows of A and stored in a @(mu)x@(ku) subblock.
 * CEIL(K/ku) of these subblocks are stored together to make a K-panel.
 * The CEIL(K/mu) K-panels are stored contiguously.  If ku does not evenly
 * divide K then the last block in the K-panel will be zero padded, and
 * similarly pad the last mu-panel if its size is less than @(mu).
 * For GEMM, this routine handles Notrans A matrices, and Trans B matrices.
 */
void ATL_USERCPMM       /* row-access matrix to access-major block */
(
   ATL_CSZT K,          /* number of rows/cols in triangular A */
   const SCALAR alpha,  /* scalar for A */
   const TYPE *A,       /* matrix to be copied to access-major format */
   ATL_CSZT lda,        /* stride between row elements */
   TYPE *b              /* OUTPUT: access-major block holding condensed A */
)
@ROUT ATL_am2rm ATL_rm2am 
{
   @iif mu } @(ku)
      @iexp koff @(mu)
   @endiif
   @iif mu < @(ku)
      @iexp koff @(ku)
   @endiif
   ATL_CSZT m = (K/@(mu))*@(mu), mr = K-m, incA = lda - m;
   ATL_CSZT KK = ((K+@(ku)-1)/@(ku))*@(ku);
   int i, j, k, pi;
   @iexp incV @(mu) @(dupB) *

   int off=0, coff=0;
   #ifdef Upper_
   for (j=0; j<K; j++, b+=@(mu), A+=(lda-j))
   {
      @(cnstb)TYPE *pp = b;  /* panel ptr */
      int poff = KK, ioff = 0;
      @iif mu < @(ku)
      for (i=0; i<(j-@(mu)+1); i+=@(mu), A+=@(mu))
      @endiif
      @iif mu } @(ku)
      for (i=0; i<(j-coff); i+=@(mu), A+=@(mu))
      @endiif
      {
         @callproc proc_rm2am_mvec_blk @(mu)
      @iif mu < @(ku)
         ioff += @(mu); if (ioff >= @(ku)) { ioff = 0; poff -= @(ku); }
      @endiif
      @iif mu } @(ku)
         poff -= @(mu);
      @endiif
         pp += poff*@(mu);
      }
      /* now copy the diag part */
      for (pi=0; i<j; i++, pi++, A++)
         pp[pi] = @(malp)(*A);
      /* diag elem */
      #ifdef UnitDiag_
         pp[pi] = @(malp)ATL_rone;
      #else
         pp[pi] = @(malp)(*A);
      #endif
      for (i++, A++, pi++ ; pi<@(mu); i++, pi++)
         pp[pi] = ATL_rzero;
      @iif mu < @(ku)
      pp += poff*@(mu);
      for (pi=coff+@(mu); pi<@(ku) && i<K; pi+=@(mu), i+=@(mu))
      {
         @callproc proc_rm2am_mvec_zero @(mu)
         pp += poff*@(mu);
      }
      @endiif
      coff++;
      if (coff >= @(koff))
      {
         coff = 0; off += @(koff);
      }
   }
@ROUT ATL_rm2am 
   @iif ku > 1
   for (; j<KK; j++, b+=@(mu))
   {
      @(cnstb)TYPE *pp = b;  /* panel ptr */
      int poff = KK, ioff = 0;
      for (i=0; i<Mmin(j,K); i+=@(mu))
      {
         @callproc proc_rm2am_mvec_zero @(mu)
      @iif mu < @(ku)
         ioff += @(mu); if (ioff >= @(ku)) { ioff = 0; poff -= @(ku); }
      @endiif
      @iif mu } @(ku)
         poff -= @(mu);
      @endiif
         pp += poff*@(mu);
      }
   }
   @endiif
@ROUT ATL_am2rm ATL_rm2am 
   #else
   for (j=0; j < m; j++, A+=incA)
   {
      @(cnstb)TYPE *pp = b+coff*@(mu);  /* panel ptr */
      int poff = off, iz = coff;
      @iif mu < @(ku)
      int zpi, ioff = 0;
      /* initial zero padding if needed */
      for (zpi=@(mu); zpi<=coff; zpi+=@(mu), iz-=@(mu))
      {
         @callproc proc_rm2am_mvec_zero @(mu)
         pp += (poff+@(ku))*@(mu);
         ioff += @(mu); if (ioff  >= @(ku)) { ioff = 0; poff+=@(ku); }
      }
      @endiif
      i = j;
      A = A+i;
      /* copy diag block */
      for (pi=0; pi < iz; pi++)
         pp[pi] = ATL_rzero;
      #ifdef UnitDiag_
         pp[pi] = @(malp)ATL_rone;
      #else
         pp[pi] = @(malp)(*A);
      #endif
      for (A++, pi++, i++; pi<@(mu); A++, pi++, i++)
         pp[pi] = @(malp)(*A);
      pp += (poff+@(koff))*@(mu);
      @iif mu < @(ku)
      ioff += @(mu); if (ioff  >= @(ku)) { ioff = 0; poff+=@(ku); }
      @endiif
      @iif mu } @(ku)
      poff += @(koff);
      @endiif
      for (; i<m; i+=@(mu), A+=@(mu))
      {
         @callproc proc_rm2am_mvec_blk @(mu)
         pp += (poff+@(koff))*@(mu);
      @iif mu < @(ku)
         ioff += @(mu); if (ioff  >= @(ku)) { ioff = 0; poff+=@(ku); }
      @endiif
      @iif mu } @(ku)
         poff += @(koff);
      @endiif
      }
      @iif mu > 1
      switch(mr)
      {
      @iexp n 1 0 +
      @iwhile n < @(mu)
      case @(n):
         @callproc proc_rm2am_mvec_blk @(n)
         break;
      @iexp n @(n) 1 +
      @endiwhile
      default:;
      }
      @endiif
      coff++; 
      if (coff >= @(koff))
      { 
         coff = 0; off += @(koff);
         b += (off+@(mu))*@(koff);
      }
   }
   @iif mu > 1
   if (mr)  /* need zero padding */
   {
      for (; j<K; j++, A += (lda-K))
      {
         @(cnstb)TYPE *pp = b+coff*@(mu);  /* panel ptr */
         int poff = off, iz = coff;
         @iif mu < @(ku)
         int zpi, ioff = 0;
         /* initial zero padding if needed */
         for (zpi=@(mu); zpi<=coff; zpi+=@(mu), iz-=@(mu))
         {
            @callproc proc_rm2am_mvec_zero @(mu)
            pp += (poff+@(ku))*@(mu);
            ioff += @(mu); if (ioff  >= @(ku)) { ioff = 0; poff+=@(ku); }
         }
         @endiif
         i = j;
         A = A+i;
         /* copy diag block */
         for (pi=0; pi<iz; pi++)
            pp[pi] = ATL_rzero;
         #ifdef UnitDiag_
            pp[pi] = @(malp)ATL_rone;
         #else
            pp[pi] = @(malp)(*A);
         #endif
         for (A++, pi++; pi<mr; A++, pi++)
            pp[pi] = @(malp)(*A);
         for ( ; pi<@(mu); pi++)
            pp[pi] = ATL_rzero;
         coff++;
         if (coff >= @(koff))
         {
            coff = 0; off += @(koff);
            b += (off+@(mu))*@(koff);
         }
      }
   }
   @endiif
@ROUT ATL_rm2am 
   @iif ku > 1
   i = coff;
   for ( ; j<KK; j++) /* ku-padding */
   {
      @(cnstb)TYPE *pp = b+coff*@(mu);  /* panel ptr */
      int poff = off;
      @iif mu < @(ku)
      int zpi, ioff = 0;
      /* initial zero padding if needed */
      for (zpi=0; zpi<i; zpi+=@(mu))
      {
         @callproc proc_rm2am_mvec_zero @(mu)
         pp += (poff+@(ku))*@(mu);
         ioff += @(mu); if (ioff  >= @(ku)) { ioff = 0; poff+=@(ku); }
      }
      @endiif
      @iif mu } @(ku)
         @callproc proc_rm2am_mvec_zero @(mu)
      @endiif
      coff++;
      if (coff >= @(koff))
      {
         coff = 0; off += @(koff);
         b += (off+@(mu))*@(koff);
      }
   }
   @endiif
@ROUT ATL_am2rm ATL_rm2am 
   #endif
}
@endiif
@ROUT ATL_cam2rm ATL_crm2am 
@beginproc proc_crm2am_kvec_elem_U
   @mif nalp ! "X
            pr[pi*@(ku)] = @(malp)ATL_rone;
            pc[pi*@(ku)] = ATL_rzero;
   @endmif
   @mif nalp = "X
            pr[pi*@(ku)] = ra;
            pc[pi*@(ku)] = ia;
   @endmif
@endproc
@beginproc proc_crm2am_kvec_elem poff aoff
   @mif nalp ! "X
            pr[@(poff)] = @(malp)A[(@(aoff)) SHIFT];
            #ifdef Conj_
               pc[@(poff)] = @(calp)A[((@(aoff)) SHIFT)+1];
            #else
               pc[@(poff)] = @(malp)A[((@(aoff)) SHIFT)+1];
            #endif
   @endmif
   @mif nalp = "X
            rv = A[(@(aoff)) SHIFT];
            #ifdef Conj_
               iv = -A[((@(aoff)) SHIFT)+1];
            #else
               iv = A[((@(aoff)) SHIFT)+1];
            #endif
            pr[@(poff)] = rv*ra - iv*ia;
            pc[@(poff)] = rv*ia + iv*ra;
   @endmif
@endproc
@beginproc proc_crm2am_kvec_zero m
@ROUT ATL_crm2am 
      @iexp i 0 0 +
      @iwhile i < @(m)
         @iexp ip @(i) @(ku) *
            pr[@(ip)] = ATL_rzero;
            pc[@(ip)] = ATL_rzero;
      @iexp i @(i) 1 +
      @endiwhile
@ROUT ATL_cam2rm ATL_crm2am 
@endproc
@beginproc proc_crm2am_kvec_blk m
@ROUT ATL_crm2am 
      @iexp i 0 0 +
      @iwhile i < @(m)
         @iexp ip @(i) @(ku) *
            @callproc proc_crm2am_kvec_elem @(ip) @(i)
         @iexp i @(i) 1 +
      @endiwhile
      @iwhile i < @(mu)
         @iexp ip @(i) @(ku) *
            pr[@(ip)] = ATL_rzero;
            pc[@(ip)] = ATL_rzero;
         @iexp i @(i) 1 +
      @endiwhile
@ROUT ATL_cam2rm ATL_crm2am 
@endproc
@iif kmaj ! 0
   @define ku @@(kmaj)@
@ROUT ATL_cam2rm
void ATL_USERCPMM       /* access- to row-major */
(
   ATL_CSZT K,          /* number of rows/cols in A */
   const SCALAR alpha,  /* scalar for A */
   const TYPE *rA,      /* access-maj blk holding condensed real(A) */
   const TYPE *iA,      /* access-maj blk holding condensed imag(A) */
   TYPE *A,             /* OUTPUT: matrix copied from access-major blk */
   ATL_CSZT lda         /* stride between row elements */
)
@ROUT ATL_crm2am 
/*
 * This routine copies the KxK triangular submatrix A into 
 * access-k-vlen-major storage.
 * In this storage, @(mu) vectors of @(ku) length are taken from the
 * @(mu) rows of A and stored in a @(ku)x@(mu) subblock.
 * CEIL(K/ku) of these subblocks are stored together to make a K-panel.
 * The CEIL(K/mu) K-panels are stored contiguously.  If ku does not evenly
 * divide K then subblocks in K-panels will be zero padded, and
 * similarly pad the last mu-panel if its size is less than @(mu). 
 * For GEMM, this routine handles NoTrans A matrices, and Trans B matrices. 
 */
void ATL_USERCPMM       /* row- to access-major */
(
   ATL_CSZT K,          /* number of rows/cols in triangular A */
   const SCALAR alpha,  /* scalar for A */
   const TYPE *A,       /* matrix to be copied to access-major format */
   ATL_CSZT lda,        /* stride between row elements */
   TYPE *rA,            /* OUTPUT: access-maj blk holding condensed real(A) */
   TYPE *iA             /* OUTPUT: access-maj blk holding condensed imag(A) */
)
@ROUT ATL_cam2rm ATL_crm2am 
{
   @iif mu } @(ku)
      @iexp koff @(mu)
   @endiif
   @iif mu < @(ku)
      @iexp koff @(ku)
   @endiif
   @iexp mu2 @(mu) @(mu) +
   ATL_CSZT m = (K/@(mu))*@(mu), mr = K-m, incA = lda - m;
   ATL_CSZT KK = ((K+@(ku)-1)/@(ku))*@(ku);
   int i, j, k, pi;
   @iif mu > @(ku)
   int pj=0, joff=0;
   @endiif
   @mif nalp = "X
   const register TYPE ra=(*alpha), ia=alpha[1];
   register TYPE rv, iv;
   @endmif
   @iexp incb @(ku) @(mu) *

   int off=0, coff=0;
   #ifdef Upper_
   for (j=0; j<K; j++, rA++, iA++, A+=((lda-j) SHIFT))
   {
      @(cnstb)TYPE *pr = rA, *pc = iA; /* panel ptrs */
      int poff = KK, ioff = 0;
      @iif mu < @(ku)
      for (i=0; i<(j-@(mu)+1); i+=@(mu), A+=@(mu2))
      @endiif
      @iif mu } @(ku)
      for (i=0; i<(j-coff); i+=@(mu), A+=@(mu2))
      @endiif
      {
         @callproc proc_crm2am_kvec_blk @(mu)
      @iif mu < @(ku)
         ioff += @(mu); if (ioff >= @(ku)) { ioff = 0; poff -= @(ku); }
      @endiif
      @iif mu } @(ku)
         poff -= @(mu);
      @endiif
         pr += poff*@(mu); pc += poff*@(mu);
      }
      /* now copy the diag part */
      for (pi=0; i<j; i++, pi++, A+=2)
      {
         @callproc proc_crm2am_kvec_elem pi*@(ku) 0
      }
      /* diag elem */
      #ifdef UnitDiag_
         @callproc proc_crm2am_kvec_elem_U
      #else
         @callproc proc_crm2am_kvec_elem pi*@(ku) 0
      #endif
      for (i++, A+=2, pi++ ; pi<@(mu); i++, pi++)
      {
         pr[pi*@(ku)] = ATL_rzero;
         pc[pi*@(ku)] = ATL_rzero;
      }
      @iif mu < @(ku)
      pr += poff*@(mu); pc += poff*@(mu);
      for (pi=coff+@(mu); pi<@(ku) && i<K; pi+=@(mu), i+=@(mu))
      {
         @callproc proc_crm2am_kvec_zero @(mu)
         pr += poff*@(mu); pc += poff*@(mu);
      }
      @endiif
      @iif mu > @(ku)
      joff++;
      if (joff >= @(ku))
      {
         joff = 0;
         rA += @(mu)*@(ku)-@(ku);
         iA += @(mu)*@(ku)-@(ku);
      }
      @endiif
      coff++;
      if (coff >= @(koff))
      {
         coff = 0; off += @(koff);
      @iif mu { @(ku)
         rA += @(koff)*@(mu)-@(koff);
         iA += @(koff)*@(mu)-@(koff);
      @endiif
      }
   }
@ROUT ATL_crm2am 
   @iif ku > 1
   for (; j<KK; j++, rA++, iA++)
   {
      @(cnstb)TYPE *pr = rA, *pc = iA;  /* panel ptr */
      int poff = KK, ioff = 0;
      for (i=0; i<Mmin(j,K); i+=@(mu))
      {
         @callproc proc_crm2am_kvec_zero @(mu)
      @iif mu < @(ku)
         ioff += @(mu); if (ioff >= @(ku)) { ioff = 0; poff -= @(ku); }
      @endiif
      @iif mu } @(ku)
         poff -= @(mu);
      @endiif
         pr += poff*@(mu); pc += poff*@(mu);
      }
   }
   @endiif
@ROUT ATL_cam2rm ATL_crm2am 
   #else
   for (j=0; j < m; j++, A+=(incA SHIFT))
   {
      @(cnstb)TYPE *pr = rA+coff, *pc = iA+coff;  /* panel ptr */
      int poff = off, iz = coff;
      @iif mu < @(ku)
      int zpi, ioff = 0;
      /* initial zero padding if needed */
      for (zpi=@(mu); zpi<=coff; zpi+=@(mu), iz-=@(mu))
      {
         @callproc proc_crm2am_kvec_zero @(mu)
         pr += (poff+@(ku))*@(mu);
         pc += (poff+@(ku))*@(mu);
         ioff += @(mu); if (ioff  >= @(ku)) { ioff = 0; poff+=@(ku); }
      }
      @endiif
      @iif mu > @(ku)
      pr += pj; pc += pj;
      @endiif
      i = j;
      A = A+(i SHIFT);
      /* copy diag block */
      for (pi=0; pi < iz; pi++)
      {
         pr[pi*@(ku)] = ATL_rzero;
         pc[pi*@(ku)] = ATL_rzero;
      }
      #ifdef UnitDiag_
         @callproc proc_crm2am_kvec_elem_U
      #else
         @callproc proc_crm2am_kvec_elem pi*@(ku) 0
      #endif
      for (A+=2, pi++, i++; pi<@(mu); A+=2, pi++, i++)
      {
         @callproc proc_crm2am_kvec_elem pi*@(ku) 0
      }
      pr += (poff+@(koff))*@(mu);
      pc += (poff+@(koff))*@(mu);
      @iif mu < @(ku)
      ioff += @(mu); if (ioff  >= @(ku)) { ioff = 0; poff+=@(ku); }
      @endiif
      @iif mu } @(ku)
      poff += @(koff);
      @endiif
      for (; i<m; i+=@(mu), A+=@(mu2))
      {
         @callproc proc_crm2am_kvec_blk @(mu)
         pr += (poff+@(koff))*@(mu);
         pc += (poff+@(koff))*@(mu);
      @iif mu < @(ku)
         ioff += @(mu); if (ioff  >= @(ku)) { ioff = 0; poff+=@(ku); }
      @endiif
      @iif mu } @(ku)
         poff += @(koff);
      @endiif
      }
      @iif mu > 1
      switch(mr)
      {
      @iexp n 1 0 +
      @iwhile n < @(mu)
      case @(n):
         @callproc proc_crm2am_kvec_blk @(n)
         break;
      @iexp n @(n) 1 +
      @endiwhile
      default:;
      }
      @endiif
      @iif mu > @(ku)
      joff++;
      if (joff >= @(ku))
      {
         joff = 0;
         pj += @(mu)*@(ku) - @(ku);
      }
      @endiif
      coff++; 
      if (coff >= @(koff))
      { 
         coff = 0; off += @(koff);
         rA += (off+@(mu))*@(koff);
         iA += (off+@(mu))*@(koff);
      @iif mu > @(ku)
         pj = 0;
      @endiif
      }
   }
   @iif mu > 1
   if (mr)  /* need zero padding */
   {
      for (; j<K; j++, A += ((lda-K) SHIFT))
      {
         @(cnstb)TYPE *pr = rA+coff, *pc = iA+coff;  /* panel ptr */
         int poff = off, iz = coff;
         @iif mu < @(ku)
         int zpi, ioff = 0;
         /* initial zero padding if needed */
         for (zpi=@(mu); zpi<=coff; zpi+=@(mu), iz-=@(mu))
         {
            @callproc proc_crm2am_kvec_zero @(mu)
            pr += (poff+@(ku))*@(mu);
            pc += (poff+@(ku))*@(mu);
            ioff += @(mu); if (ioff  >= @(ku)) { ioff = 0; poff+=@(ku); }
         }
         @endiif
         @iif mu > @(ku)
         pr += pj; pc += pj;
         @endiif
         i = j;
         A = A+(i SHIFT);
         /* copy diag block */
         for (pi=0; pi<iz; pi++)
         {
            pr[pi*@(ku)] = ATL_rzero;
            pc[pi*@(ku)] = ATL_rzero;
         }
         #ifdef UnitDiag_
            @callproc proc_crm2am_kvec_elem_U
         #else
            @callproc proc_crm2am_kvec_elem pi*@(ku) 0
         #endif
         for (A+=2, pi++; pi<mr; A+=2, pi++)
         {
            @callproc proc_crm2am_kvec_elem pi*@(ku) 0
         }
         for ( ; pi<@(mu); pi++)
         {
            pr[pi*@(ku)] = ATL_rzero;
            pc[pi*@(ku)] = ATL_rzero;
         }
         @iif mu > @(ku)
         joff++;
         if (joff >= @(ku))
         {
            joff = 0;
            pj += @(mu)*@(ku) - @(ku);
         }
         @endiif
         coff++;
         if (coff >= @(koff))
         {
            coff = 0; off += @(koff);
            rA += (off+@(mu))*@(koff);
            iA += (off+@(mu))*@(koff);
         @iif mu > @(ku)
            pj = 0;
         @endiif
         }
      }
   }
   @endiif
@ROUT ATL_crm2am 
   @iif ku > 1
   i = coff;
   for ( ; j<KK; j++) /* ku-padding */
   {
      @(cnstb)TYPE *pr = rA+coff, *pc = iA+coff;  /* panel ptr */
      int poff = off;
      @iif mu < @(ku)
      int zpi, ioff = 0;
      /* initial zero padding if needed */
      for (zpi=0; zpi<i; zpi+=@(mu))
      {
         @callproc proc_crm2am_kvec_zero @(mu)
         pr += (poff+@(ku))*@(mu);
         pc += (poff+@(ku))*@(mu);
         ioff += @(mu); if (ioff  >= @(ku)) { ioff = 0; poff+=@(ku); }
      }
      @endiif
      @iif mu > @(ku)
      pr += pj; pc += pj;
      @endiif
      @iif mu } @(ku)
         @callproc proc_crm2am_kvec_zero @(mu)
      @endiif
      @iif mu > @(ku)
      joff++;
      if (joff >= @(ku))
      {
         joff = 0;
         pj += @(mu)*@(ku) - @(ku);
      }
      @endiif
      coff++;
      if (coff >= @(koff))
      {
         coff = 0; off += @(koff);
         rA += (off+@(mu))*@(koff);
         iA += (off+@(mu))*@(koff);
      }
   }
   @endiif
@ROUT ATL_cam2rm ATL_crm2am 
   #endif
}
@endiif
@beginproc proc_crm2am_mvec_elem_U
   @mif nalp ! "X
            pr[pi] = @(malp)ATL_rone;
            pc[pi] = ATL_rzero;
   @endmif
   @mif nalp = "X
            pr[pi] = ra;
            pc[pi] = ia;
   @endmif
@endproc
@beginproc proc_crm2am_mvec_elem poff aoff
   @mif nalp ! "X
            pr[@(poff)] = @(malp)A[(@(aoff)) SHIFT];
            #ifdef Conj_
               pc[@(poff)] = @(calp)A[((@(aoff)) SHIFT)+1];
            #else
               pc[@(poff)] = @(malp)A[((@(aoff)) SHIFT)+1];
            #endif
   @endmif
   @mif nalp = "X
            rv = A[(@(aoff)) SHIFT];
            #ifdef Conj_
               iv = -A[((@(aoff)) SHIFT)+1];
            #else
               iv = A[((@(aoff)) SHIFT)+1];
            #endif
            pr[@(poff)] = rv*ra - iv*ia;
            pc[@(poff)] = rv*ia + iv*ra;
   @endmif
@endproc
@beginproc proc_crm2am_mvec_zero m
@ROUT ATL_crm2am 
      @iexp i 0 0 +
      @iwhile i < @(m)
         pr[@(i)] = pc[@(i)] = ATL_rzero;
      @iexp i @(i) 1 +
      @endiwhile
@ROUT ATL_cam2rm ATL_crm2am 
@endproc
@beginproc proc_crm2am_mvec_blk m
      @iexp i 0 0 +
      @iwhile i < @(m)
         @callproc proc_crm2am_mvec_elem @(i) @(i)
         @iexp i @(i) 1 +
      @endiwhile
@ROUT ATL_crm2am 
      @iwhile i < @(mu)
         pr[@(i)] = pc[@(i)] = ATL_rzero;
         @iexp i @(i) 1 +
      @endiwhile
@ROUT ATL_cam2rm ATL_crm2am 
@endproc
@iif kmaj = 0
@ROUT ATL_cam2rm
/*
 * Copies from (M-vectorized) access-major storage triangular block b back
 * to column-major storage A, with possible scale. 
 * This routine handles Trans B matrices and NoTrans A matrices. 
 */
void ATL_USERCPMM       /* access- to row-major */
(
   ATL_CSZT K,          /* number of rows/cols in triangular A */
   const SCALAR alpha,  /* scalar for rA,iA */
   const TYPE *rA,      /* access-maj blk holding condensed real(A) */
   const TYPE *iA,      /* access-maj blk holding condensed imag(A) */
   TYPE *A,             /* OUTPUT: submatrix dest for access-major blk */
   ATL_CSZT lda         /* stride between row elements */
)
@ROUT ATL_crm2am 
/*
 * This routine copies the KxK triangular submatrix A into 
 * the CEIL(K/@(ku))xCEIL(K/@(mu)) blocks rA, iA.
 * ?A are stored in access-major storage, where the @(mu) unrolled accesses
 * are assumed to come from the rows of A.
 * It is for M-vectorized storage.
 * More specifically, the @(mu)xK row panel of A becomes a @(mu)xK region
 * in b, and if the last such row panel is partial, it is zero padded.
 * For GEMM, this routine handles Notrans A matrices, and Trans B matrices.
 */
void ATL_USERCPMM       /* row- to access-major */
(
   ATL_CSZT K,          /* number of rows/cols in triangular A */
   const SCALAR alpha,  /* scalar for A */
   const TYPE *A,       /* matrix to be copied to access-major format */
   ATL_CSZT lda,        /* stride between row elements */
   TYPE *rA,            /* OUTPUT: access-maj blk holding condensed real(A) */
   TYPE *iA             /* OUTPUT: access-maj blk holding condensed imag(A) */
)
@ROUT ATL_cam2rm ATL_crm2am 
{
   @iif mu } @(ku)
      @iexp koff @(mu)
   @endiif
   @iif mu < @(ku)
      @iexp koff @(ku)
   @endiif
   @iexp mu2 @(mu) @(mu) +
   ATL_CSZT m = K/@(mu)*@(mu), mr = K-m, incA = lda - m;
   ATL_CSZT KK = ((K+@(ku)-1)/@(ku))*@(ku);
   int i, j, k, pi;
   @mif nalp = "X
   const register TYPE ra=(*alpha), ia=alpha[1];
   register TYPE rv, iv;
   @endmif

   int off=0, coff=0;
   #ifdef Upper_
   for (j=0; j<K; j++, rA+=@(mu), iA+=@(mu), A+=((lda-j) SHIFT))
   {
      @(cnstb)TYPE *pr = rA, *pc = iA;  /* panel ptrs */
      int poff = KK, ioff = 0;
      @iif mu < @(ku)
      for (i=0; i<(j-@(mu)+1); i+=@(mu), A+=@(mu2))
      @endiif
      @iif mu } @(ku)
      for (i=0; i<(j-coff); i+=@(mu), A+=@(mu2))
      @endiif
      {
         @callproc proc_crm2am_mvec_blk @(mu)
      @iif mu < @(ku)
         ioff += @(mu); if (ioff >= @(ku)) { ioff = 0; poff -= @(ku); }
      @endiif
      @iif mu } @(ku)
         poff -= @(mu);
      @endiif
         pr += poff*@(mu);
         pc += poff*@(mu);
      }
      /* now copy the diag part */
      for (pi=0; i<j; i++, pi++, A+=2)
      {
         @callproc proc_crm2am_mvec_elem pi 0
      }
      /* diag elem */
      #ifdef UnitDiag_
         @callproc proc_crm2am_mvec_elem_U
      #else
         @callproc proc_crm2am_mvec_elem pi 0
      #endif
      for (i++, A+=2, pi++ ; pi<@(mu); i++, pi++)
      {
         pr[pi] = ATL_rzero;
         pc[pi] = ATL_rzero;
      }
      @iif mu < @(ku)
      pr += poff*@(mu);
      pc += poff*@(mu);
      for (pi=coff+@(mu); pi<@(ku) && i<K; pi+=@(mu), i+=@(mu))
      {
         @callproc proc_crm2am_mvec_zero @(mu)
         pr += poff*@(mu);
         pc += poff*@(mu);
      }
      @endiif
      coff++;
      if (coff >= @(koff))
      {
         coff = 0; off += @(koff);
      }
   }
@ROUT ATL_crm2am 
   @iif ku > 1
   for (; j<KK; j++, rA+=@(mu), iA+=@(mu))
   {
      @(cnstb)TYPE *pr = rA, *pc = iA;  /* panel ptrs */
      int poff = KK, ioff = 0;
      for (i=0; i<Mmin(j,K); i+=@(mu))
      {
         @callproc proc_crm2am_mvec_zero @(mu)
      @iif mu < @(ku)
         ioff += @(mu); if (ioff >= @(ku)) { ioff = 0; poff -= @(ku); }
      @endiif
      @iif mu } @(ku)
         poff -= @(mu);
      @endiif
         pr += poff*@(mu);
         pc += poff*@(mu);
      }
   }
   @endiif
@ROUT ATL_cam2rm ATL_crm2am 
   #else
   for (j=0; j < m; j++, A+=(incA SHIFT))
   {
      @(cnstb)TYPE *pr = rA+coff*@(mu), *pc = iA+coff*@(mu);  /* panel ptr */
      int poff = off, iz = coff;
      @iif mu < @(ku)
      int zpi, ioff = 0;
      /* initial zero padding if needed */
      for (zpi=@(mu); zpi<=coff; zpi+=@(mu), iz-=@(mu))
      {
         @callproc proc_crm2am_mvec_zero @(mu)
         pr += (poff+@(ku))*@(mu);
         pc += (poff+@(ku))*@(mu);
         ioff += @(mu); if (ioff  >= @(ku)) { ioff = 0; poff+=@(ku); }
      }
      @endiif
      i = j;
      A = A + (i SHIFT);
      /* copy diag block */
      for (pi=0; pi < iz; pi++)
      {
         pr[pi] = ATL_rzero;
         pc[pi] = ATL_rzero;
      }
      #ifdef UnitDiag_
         @callproc proc_crm2am_mvec_elem_U
      #else
         @callproc proc_crm2am_mvec_elem pi 0
      #endif
      for (A+=2, pi++, i++; pi<@(mu); A+=2, pi++, i++)
      {
         @callproc proc_crm2am_mvec_elem pi 0
      }
      pr += (poff+@(koff))*@(mu);
      pc += (poff+@(koff))*@(mu);
      @iif mu < @(ku)
      ioff += @(mu); if (ioff  >= @(ku)) { ioff = 0; poff+=@(ku); }
      @endiif
      @iif mu } @(ku)
      poff += @(koff);
      @endiif
      for (; i<m; i+=@(mu), A+=@(mu2))
      {
         @callproc proc_crm2am_mvec_blk @(mu)
         pr += (poff+@(koff))*@(mu);
         pc += (poff+@(koff))*@(mu);
      @iif mu < @(ku)
         ioff += @(mu); if (ioff  >= @(ku)) { ioff = 0; poff+=@(ku); }
      @endiif
      @iif mu } @(ku)
         poff += @(koff);
      @endiif
      }
      @iif mu > 1
      switch(mr)
      {
      @iexp n 1 0 +
      @iwhile n < @(mu)
      case @(n):
         @callproc proc_crm2am_mvec_blk @(n)
         break;
      @iexp n @(n) 1 +
      @endiwhile
      default:;
      }
      @endiif
      coff++; 
      if (coff >= @(koff))
      { 
         coff = 0; off += @(koff);
         rA += (off+@(mu))*@(koff);
         iA += (off+@(mu))*@(koff);
      }
   }
   @iif mu > 1
   if (mr)  /* need zero padding */
   {
      for (; j<K; j++, A += ((lda-K) SHIFT))
      {
         @(cnstb)TYPE *pr = rA+coff*@(mu), *pc = iA+coff*@(mu);  /* panel ptr */
         int poff = off, iz = coff;
         @iif mu < @(ku)
         int zpi, ioff = 0;
         /* initial zero padding if needed */
         for (zpi=@(mu); zpi<=coff; zpi+=@(mu), iz-=@(mu))
         {
            @callproc proc_crm2am_mvec_zero @(mu)
            pr += (poff+@(ku))*@(mu);
            pc += (poff+@(ku))*@(mu);
            ioff += @(mu); if (ioff  >= @(ku)) { ioff = 0; poff+=@(ku); }
         }
         @endiif
         i = j;
         A = A + (i SHIFT);
         /* copy diag block */
         for (pi=0; pi<iz; pi++)
         {
            pr[pi] = ATL_rzero;
            pc[pi] = ATL_rzero;
         }
         #ifdef UnitDiag_
            @callproc proc_crm2am_mvec_elem_U
         #else
            @callproc proc_crm2am_mvec_elem pi 0
         #endif
         for (A+=2, pi++; pi<mr; A+=2, pi++)
         {
            @callproc proc_crm2am_mvec_elem pi 0
         }
         for ( ; pi<@(mu); pi++)
         {
            pr[pi] = ATL_rzero;
            pc[pi] = ATL_rzero;
         }
         coff++;
         if (coff >= @(koff))
         {
            coff = 0; off += @(koff);
            rA += (off+@(mu))*@(koff);
            iA += (off+@(mu))*@(koff);
         }
      }
   }
   @endiif
@ROUT ATL_crm2am 
   @iif ku > 1
   i = coff;
   for ( ; j<KK; j++) /* ku-padding */
   {
      @(cnstb)TYPE *pr = rA+coff*@(mu), *pc = iA+coff*@(mu);  /* panel ptrs */
      int poff = off;
      @iif mu < @(ku)
      int zpi, ioff = 0;
      /* initial zero padding if needed */
      for (zpi=0; zpi<i; zpi+=@(mu))
      {
         @callproc proc_crm2am_mvec_zero @(mu)
         pr += (poff+@(ku))*@(mu);
         pc += (poff+@(ku))*@(mu);
         ioff += @(mu); if (ioff  >= @(ku)) { ioff = 0; poff+=@(ku); }
      }
      @endiif
      @iif mu } @(ku)
         @callproc proc_crm2am_mvec_zero @(mu)
      @endiif
      coff++;
      if (coff >= @(koff))
      {
         coff = 0; off += @(koff);
         rA += (off+@(mu))*@(koff);
         iA += (off+@(mu))*@(koff);
      }
   }
   @endiif
@ROUT ATL_cam2rm ATL_crm2am 
   #endif
}
@endiif

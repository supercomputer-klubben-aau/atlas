@ROUT !
   @define pre @@(@pre)@
   @PRE S C
      @define typ @float@
      @define sz @4@
   @PRE D Z
      @define sz @8@
      @define typ @double@
   @PRE !
#define ATL_VLEN @(vl)
#if !defined(SREAL) && !defined(DREAL) && !defined(SCPLX) && !defined(DCPLX)
   @PRE C `   #define SCPLX 1`
   @PRE S `   #define SREAL 1`
   @PRE D `   #define DREAL 1`
   @PRE Z `   #define DCPLX 1`
#endif
@ifdef ! TRI
   @iexp TRI 0
@endifdef
@SKIP TRI = 1 means lower triangular C (SYRK)
@iif TRI = 1
   @define ma @1@
   @define na @1@
   @iif mu ! nu
      @iif mu > nu
         @iexp ma @(nu) @(mu) / 
         @iexp mma @(ma) @(nu) *
         @iif mu ! mma
           @abort "mu (@(mu)) must be mupliple of nu (@(nu))"  
         @endiif
         @skip @print ************ma = @(ma)
      @endiif
      @iif nu > mu
         @iexp na @(mu) @(nu) / 
         @iexp nna @(na) @(mu) *
         @iif nu ! nna
           @abort "nu (@(nu)) must be mupliple of mu (@(mu))"  
         @endiif
         @skip @print ************na = @(na)
      @endiif
      @define mEn @0@
   @endiif
   @iif mu = nu
      @define mEn @1@
   @endiif
@endiif
@ROUT blk2C C2blk
#include <stddef.h>
@ifdef ! cpvl
   @iexp cpvl 1
@endifdef
@iif vl = 0
   @iexp vl 1
@endiif
@iif cpvl > 1
#define ATL_VLEN @(vl)
#include "atlas_simd.h"
@endiif
#if defined(__STDC_VERSION__) && (__STDC_VERSION__/100 >= 1999)
   #define INLINE inline
#endif
@SKIP LEGAL: alpha=[1,-1,X], beta=[0,1,-1,X]
@SKIP if (alpha==1) && (beta==0 || beta==1)) -> char same as #
@ifdef ! rtnm
   @define rtnm @ATL_USERCPMM@
@endifdef
@SKIP ***********************copy routines for real type********************** 
@PRE S D
@SKIP blksz = ((mu*nu+vlen-1)/vlen)*vlen
@iexp bs @(vl) @(mu) @(nu) * @(vl) + -1 + / @(vl) *
/* HERE vl=@(vl), mu=@(mu), nu=@(nu) bs=@(bs) */
@SKIP this proc handles only one element
@SKIP IN : alpha, beta, C, p 
@BEGINPROC doElement r c k
         @iif alpha = 1
            @iif beta = 0
@ROUT blk2C `            C@(c)[@(r)] = p[@(k)];`
@ROUT C2blk `            p[@(k)] = C@(c)[@(r)];`
            @endiif
            @iif beta = 1
@ROUT blk2C `            C@(c)[@(r)] += p[@(k)];`
@ROUT C2blk `            p[@(k)] += C@(c)[@(r)];`
            @endiif
            @iif beta = -1
@ROUT blk2C `            C@(c)[@(r)] = p[@(k)] - C@(c)[@(r)];`
@ROUT C2blk `            p[@(k)] = C@(c)[@(r)] - p[@(k)];`
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `            C@(c)[@(r)] = beta*C@(c)[@(r)] + p[@(k)];`
@ROUT C2blk `            p[@(k)] = beta*p[@(k)] + C@(c)[@(r)];`
            @endiif
         @endiif
         @iif alpha = -1
            @iif beta = 0
@ROUT blk2C `            C@(c)[@(r)] = -p[@(k)];`
@ROUT C2blk `            p[@(k)] = -C@(c)[@(r)];`
            @endiif
            @iif beta = 1
@ROUT blk2C `            C@(c)[@(r)] -= p[@(k)];`
@ROUT C2blk `            p[@(k)] -= C@(c)[@(r)];`
            @endiif
            @iif beta = -1
@ROUT blk2C `            C@(c)[@(r)] = -C@(c)[@(r)] - p[@(k)];`
@ROUT C2blk `            p[@(k)] = -C@(c)[@(r)] - p[@(k)];`
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `            C@(c)[@(r)] = beta*C@(c)[@(r)] - p[@(k)];`
@ROUT C2blk `            p[@(k)] = beta*p[@(k)] - C@(c)[@(r)];`
            @endiif
         @endiif
         @iif @iexp @(alpha) 1 ! @(alpha) -1 ! &
            @iif beta = 0
@ROUT blk2C `            C@(c)[@(r)] = alpha*p[@(k)];`
@ROUT C2blk `            p[@(k)] = alpha*C@(c)[@(r)];`
            @endiif
            @iif beta = 1
@ROUT blk2C `            C@(c)[@(r)] += alpha*p[@(k)];`
@ROUT C2blk `            p[@(k)] += alpha*C@(c)[@(r)];`
            @endiif
            @iif beta = -1
@ROUT blk2C `            C@(c)[@(r)] = alpha*p[@(k)] - C@(c)[@(r)];`
@ROUT C2blk `            p[@(k)] = alpha*C@(c)[@(r)] - p[@(k)];`
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `            C@(c)[@(r)] = beta*C@(c)[@(r)] + alpha*p[@(k)];`
@ROUT C2blk `            p[@(k)] = beta*p[@(k)] + alpha*C@(c)[@(r)];`
            @endiif
         @endiif
@ENDPROC
@SKIP handles diagonal blocks when mu = nu 
@SKIP IN: mu, nu, beta, alpha
@BEGINPROC doDiBlock n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define c @dum@
   @define r @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
         @iexp k @(j) @(mu) * @(i) +
@ROUT blk2C
         @iexp r @(i)
         @iexp c @(j)
         @iif j { i
@ROUT C2blk
         @iif j > i
            @iexp r @(j)
            @iexp c @(i)
         @endiif
         @iif j { i
            @iexp r @(i)
            @iexp c @(j)
         @endiif
@ROUT blk2C C2blk
      @callproc doElement @(r) @(c) @(k)  
@ROUT blk2C 
         @endiif
@ROUT blk2C C2blk
         @iexp i @(i) 1 +
      @endiwhile
      @iif n_ = mu
            C@(j) += @(mu);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef r
   @undef c
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP handles diagonal subblocks when mu=ma*nu
@SKIP IN: mu, nu, beta, alpha
@BEGINPROC doDiBlockmn m_ n_ ma_
   @define i @dum@
   @define j @dum@
   @define jj @dum@
   @define k @dum@
   @define t @dum@
   @define sc @dum@
      switch (j%@(ma_))
      {
      @iexp sc 0
      @iwhile sc < @(ma_)
      case @(sc):
         @iexp j 0
         @iwhile j < @(n_)  
            @iexp i 0
            @iwhile i < @(m_) 
               @iexp k @(j) @(mu) * @(i) +
               @iexp t @(nu) @(sc) *
               @iexp t @(t) @(j) +
               @iif i < @(t) 
@ROUT C2blk    
               @iexp jj @(m_) -1 +    
               @callproc doElement @(jj) @(j) @(k) 
@ROUT C2blk blk2C
               @endiif
               @iif i } @(t)
               @callproc doElement @(i) @(j) @(k)
               @endiif
               @iexp i @(i) 1 +
            @endiwhile
         C@(j) += @(m_);
            @iexp j @(j) 1 +
         @endiwhile
         break;
         @iexp sc @(sc) 1 +
      @endiwhile
      default:;
      }
   @undef sc
   @undef t
   @undef k
   @undef jj
   @undef j
   @undef i
@ENDPROC
@SKIP cleanup diagonal subblocks when mu!=nu 
@SKIP IN: mu, nu, beta, alpha,
@BEGINPROC doCuDiBlockmn m_ n_ ma_
   @define i @dum@
   @define j @dum@
   @define jj @dum@
   @define k @dum@
   @define t @dum@
   @define sc @dum@
   @define m @dum@
      unsigned int kk;
      switch (j%@(ma_))
      {
      @iexp m @(ma_) -1 +
      @iexp sc 0
      @iwhile sc < @(m)
      case @(sc):
         @iexp j 0
         @iwhile j < @(n_)  
            @iexp i 0 
            @iwhile i < @(m_) 
               @iexp k @(j) @(mu) * @(i) +
               @iexp t @(nu) @(sc) *
               @iexp t @(t) @(j) +
@ROUT C2blk    
               @iif i < @(t) 
               @iexp jj @(i) 1 +    
            p[@(k)] = 0.0;
               @endiif
@ROUT C2blk blk2C
               @iif i } @(t)
                  @skip "upper limit"
                  @iexp t @(sc) 1 +
                  @iexp t @(t) @(nu) *
                  @iif i < @(t)
            @callproc doElement @(i) @(j) @(k)
                  @endiif
               @endiif
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
            @skip "now from nu to mu "
            @iexp jj @(sc) 1 +
            @iexp jj @(jj) @(n_) *
         for (kk=@(jj); kk < mr; kk++ )
         {
               @iexp jj 0
               @iwhile jj < @(n_)
                  @iexp t @(jj) @(m_) * 
                  @callproc doElement kk @(jj) @(t)+kk
                  @iexp jj @(jj) 1 +
               @endiwhile
         }
         break;
         @iexp sc @(sc) 1 +
      @endiwhile
      default:;
      }
   @undef m
   @undef sc
   @undef t
   @undef k
   @undef jj
   @undef j
   @undef i
@ENDPROC
@SKIP diagonal block when nu > mu and nu = na * mu
@BEGINPROC doDikkBlockna n_ mul_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define c @dum@
   @define r @dum@
   @define m @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
         @iexp k @(j) @(mu) * @(i) +
@ROUT blk2C
         @iexp r @(i)
         @iexp c @(j)
         @iif j { i
@ROUT C2blk
         @iif j > i
            @iexp r @(j)
            @iexp c @(i)
         @endiif
         @iif j { i
            @iexp r @(i)
            @iexp c @(j)
         @endiif
@ROUT blk2C C2blk
         @skip @iexp m @(n_) @(n_) *
         @callproc doElement @(r) @(c) @(k)+kk*@(mul_) 
@ROUT blk2C
         @endiif
@ROUT blk2C C2blk
         @iexp i @(i) 1 +
      @endiwhile
      @iif n_ = mu
            C@(j) += @(mu);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef m
   @undef r
   @undef c
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP handles square blocks 
@BEGINPROC doBlock m_ n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp k @(j) @(mu) * @(i) +
         @callproc doElement @(i) @(j) @(k) 
         @iexp i @(i) 1 +
      @endiwhile
      @iif m_ = mu
            C@(j) += @(mu);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP full blocks with multiplication 
@BEGINPROC donaBlock m_ n_ mn_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define m @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp k @(j) @(mu) * @(i) +
         @callproc doElement @(i) @(j) @(k)+kk*@(mn_) 
         @iexp i @(i) 1 +
      @endiwhile
      @iif m_ = mu
            C@(j) += @(mu);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef m
   @undef k
   @undef j
   @undef i
@ENDPROC
@iif cpvl = 1
void @(rtnm)
(
   const size_t M,      /* number of rows in A */
   const size_t N,      /* number of columns in A */
   @ROUT blk2C
   const @(typ) alpha,  /* scalar for b */
   const @(typ) *b,     /* matrix stored in @(mu)x@(nu)-major order */
   const @(typ) beta,   /* scalar for C */
   @(typ) *C,           /* matrix to be copied to access-major format */
   const size_t ldc     /* stride between row elements */
   @ROUT C2blk
   const @(typ) alpha,  /* scalar for C */
   const @(typ) *C,     /* matrix to be copied to access-major format */
   const size_t ldc,    /* stride between row elements */
   const @(typ) beta,   /* scalar for b */
   @(typ) *b            /* matrix stored in @(mu)x@(nu)-major order */
   @ROUT C2blk blk2C
)
@endiif
@iif cpvl > 1
static INLINE void a2c_1(const size_t M, const size_t N, const @(typ) alpha, 
                         const @(typ) *b, const SCALAR beta, 
                         @(typ) *C, ATL_CSZT ldc)
@endiif
{
@SKIP ********************** GEMM copy: real type ******************************
@iif TRI = 0
   const unsigned int mf = M/@(mu), nf = N/@(nu);
   const unsigned int m = mf*@(mu), n = nf*@(nu), mr = M-m, nr = N-n;
   const unsigned int pansz = (nr) ? (nf+1)*@(bs) : nf*@(bs); /* bs=@(bs) */
   const size_t incC = ldc*@(nu) - m;
   unsigned int i, j;
@ROUT blk2C `   @declare "   @(typ) " n n ";"`
@ROUT C2blk `   @declare "   const @(typ) " n n ";"`
      *C0=C
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
   for (j=nf; j; j--, b += @(bs))
   {
@ROUT blk2C `      const @(typ) *p = b;`
@ROUT C2blk `      @(typ) *p = b;`
      for (i=mf; i; i--, p += pansz)
      {
         @callproc doBlock @(mu) @(nu)
      }
      switch(mr)
      {
   @iexp m 1
   @iwhile m < @(mu)
      case @(m):
      @callproc doBlock @(m) @(nu)
      @iexp m @(m) 1 +
         break;
   @endiwhile
      default:;
      }
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
   }
@iif nu > 1
   switch(nr)
   {
@ROUT blk2C `      const @(typ) *p;`
@ROUT C2blk `      @(typ) *p;`
   @iexp n 1
   @iwhile n < @(nu)
   case @(n):
      p = b;
      for (i=0; i < mf; i++, p += pansz)
      {
         @callproc doBlock @(mu) @(n)
      }
      switch(mr)
      {
   @iexp m 1
   @iwhile m < @(mu)
      case @(m):
      @callproc doBlock @(m) @(n)
      @iexp m @(m) 1 +
         break;
   @endiwhile
      default:;
      }
      break;
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
@endiif
@endiif
@SKIP ******************** SYRK copy: real type ********************************
@iif TRI = 1
   const unsigned int mf = M/@(mu), nf = N/@(nu);
   const unsigned int m = mf*@(mu), n = nf*@(nu), mr = M-m, nr = N-n;
   @iif mEn = 1
   unsigned int pansz = @(bs);
   const size_t incC0 = (ldc+1)*@(nu);
   @endiif
   @iif mEn = 0
      @skip "*** special case for mu = ma*nu"
      @iif ma ! 1
   unsigned int pansz = @(bs)*@(ma);
   const unsigned int manf = (N/(@(nu)*@(ma)))*@(ma);
   const unsigned int manr = nf - manf;
   const size_t incC0 = ldc*@(nu);
      @endiif 
      @skip "*** special case for nu = na * mu"
      @iif na ! 1
   unsigned int pansz = @(bs);
   const size_t incC0 = (ldc+1)*@(mu); 
   const unsigned int mnf = N/@(mu);
   const unsigned int mnr = N - (mnf*@(mu));
   unsigned int kk; 
      @endiif
   @endiif
   unsigned int i, j;
@ROUT blk2C `   @declare "   @(typ) " n n ";"`
@ROUT C2blk `   @declare "   const @(typ) " n n ";"`
      *C0=C
@iif na = 1
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
@endiif
@iif na ! 1
      @define j @1@
      @iwhile j < @(mu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
@endiif
   @iif mEn = 1
   for (j=0; j < nf; j++)
   @endiif
   @iif mEn = 0
      @iif ma ! 1
   size_t incC;
   for (j=0; j < manf; j++)
      @endiif
      @iif na ! 1
   for (j=0; j < mnf; j++)
      @endiif
   @endiif
   {
@ROUT blk2C `      const @(typ) *p = b;`
@ROUT C2blk `      @(typ) *p = b;`
   @iif mEn = 1
      unsigned int psz = pansz+@(bs), incC = incC0 - (mf-j)*@(mu);

      @callproc doDiBlock @(nu)
      p += pansz;
      for (i=j+1; i < mf; i++, p += psz, psz += @(bs))
   @endiif
   @iif mEn = 0
      @iif ma ! 1
      unsigned int psz = pansz + @(ma)*@(bs); 
      incC = incC0 - (mf-(j+1)/@(ma))*@(mu);
      @callproc doDiBlockmn @(mu) @(nu) @(ma)
      p += pansz;
      for (i=j/@(ma)+1; i < mf; i++, p += psz, psz += @(bs)*@(ma))
      @endiif
      @iif na ! 1
      unsigned int psz = pansz, incC = incC0 - (mf-j)*@(mu);
         kk = j % @(na);
      @iexp mumu @(mu) @(mu) *
      @callproc doDikkBlockna @(mu) @(mumu)
      p += pansz;
      for (i=j+1; i < mf; i++, p += psz )
      @endiif
   @endiif
@iif na = 1
      {
         @callproc doBlock @(mu) @(nu)
      }
@endiif
@iif na ! 1
      {
         @callproc donaBlock @(mu) @(mu) @(mumu)
         psz += ((i%@(na))==0?@(bs):0);
      }
@endiif
      switch(mr)
      {
   @iexp m 1
   @iwhile m < @(mu)
      case @(m):
@iif na = 1
      @callproc doBlock @(m) @(nu)
@endiif
@iif na ! 1
      @callproc donaBlock @(m) @(mu) @(mumu)
@endiif
      @iexp m @(m) 1 +
         break;
   @endiwhile
      default:;
      }
@iif na = 1
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
@endiif
@iif na ! 1
   @iexp j 0
   @iwhile j < @(mu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
@endiif
   @iif mEn = 1
      pansz += @(bs);
      b += pansz;
   @endiif
   @iif mEn = 0
      @iif ma ! 1
      b += ((j+1)% @(ma))==0 ? pansz+@(bs) : @(bs);
      if ( (j+1) % @(ma) == 0)
         pansz += @(ma)*@(bs);
      @endiif
      @iif na ! 1
      pansz += ((j+1)%@(na)==0?@(bs):0);
      b += pansz;
      @endiif
   @endiif
   }
      @SKIP "Remainder of manr = nf - manf " 
   @iif mEn = 0
      @iif ma ! 1
   for (j=manf; j < nf; j++)
   {
@ROUT blk2C `      const @(typ) *p = b;`
@ROUT C2blk `      @(typ) *p = b;`
      unsigned int psz = pansz + @(ma)*@(bs), 
                         incC = incC0 - (mf-(j+1)/@(ma))*@(mu);
         @callproc doCuDiBlockmn @(mu) @(nu) @(ma)
      p += pansz;
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
      b += ((j+1)% @(ma))==0 ? pansz+@(bs) : @(bs);
      if ( (j+1) % @(ma) == 0)
         pansz += @(ma)*@(bs);
   }
         @endiif
      @endiif
@iif na = 1
@iif nu > 1
   switch(nr)
   {
@ROUT blk2C `      const @(typ) *p;`
@ROUT C2blk `      @(typ) *p;`
   @iexp n 1
   @iwhile n < @(nu)
   case @(n):
      p = b;
   @iif mEn = 1
         @callproc doDiBlock @(n)
   @endiif
   @iif mEn = 0
      @iif ma ! 1
         p += mr - nr; 
         @iexp k 0
         @iwhile k < @(n)
            C@(k) += mr-nr;
            @iexp k @(k) 1 +
         @endiwhile
         @skip "for nr cleanup, it works like mu=nu"
         @callproc doDiBlock @(n)
      @endiif
   @endiif
      break;
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
@endiif
@endiif
@iif na ! 1
@iif mu > 1
   kk = mnf % @(na);
   switch(mnr)
   {
@ROUT blk2C `      const @(typ) *p;`
@ROUT C2blk `      @(typ) *p;`
   @iexp n 1
   @iwhile n < @(mu)
   case @(n):
      p = b;
      @callproc doDikkBlockna @(n) @(mumu)
         break;
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
@endiif
@endiif
@SKIP ********** END of SYRK copy: real type ***********************************
@endiif
}
@SKIP ********** SYRK L2UT copy: real type *************************************
@iif TRI = 1
@SKIP this proc handles single element
@SKIP IN : alpha, beta, C, b 
@BEGINPROC doElementT r_ c_ k_
   @iif alpha = 1
      @iif beta = 0
@ROUT blk2C `            C@(c_)[@(r_)] = b[@(k_)];`
@ROUT C2blk `            b[@(k_)] = C@(c_)[@(r_)];`
      @endiif
      @iif beta = 1
@ROUT blk2C `            C@(c_)[@(r_)] += b[@(k_)];`
@ROUT C2blk `            b[@(k_)] += C@(c_)[@(r_)];`
      @endiif
      @iif beta = -1
@ROUT blk2C `            C@(c_)[@(r_)] = b[@(k_)] - C@(c_)[@(r_)];`
@ROUT C2blk `            b[@(k_)] = C@(c_)[@(r_)] - b[@(k_)];`
      @endiif
      @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `            C@(c_)[@(r_)] = beta*C@(c_)[@(r_)] + b[@(k_)];`
@ROUT C2blk `            b[@(k_)] = beta*b[@(k_)] + C@(c_)[@(r_)];`
      @endiif
   @endiif
   @iif alpha = -1
      @iif beta = 0
@ROUT blk2C `            C@(c_)[@(r_)] = -b[@(k_)];`
@ROUT C2blk `            b[@(k_)] = -C@(c_)[@(r_)];`
      @endiif
      @iif beta = 1
@ROUT blk2C `            C@(c_)[@(r_)] -= b[@(k_)];`
@ROUT C2blk `            b[@(k_)] -= C@(c_)[@(r_)];`
      @endiif
      @iif beta = -1
@ROUT blk2C `            C@(c_)[@(r_)] = -C@(c_)[@(r_)] - b[@(k_)];`
@ROUT C2blk `            b[@(k_)] = -C@(c_)[@(r_)] - b[@(k_)];`
      @endiif
      @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `            C@(c_)[@(r_)] = beta*C@(c_)[@(r_)] - b[@(k_)];`
@ROUT C2blk `            b[@(k_)] = beta*b[@(k_)] - C@(c_)[@(r_)];`
      @endiif
   @endiif
   @iif @iexp @(alpha) 1 ! @(alpha) -1 ! &
      @iif beta = 0
@ROUT blk2C `            C@(c_)[@(r_)] = alpha*b[@(k_)];`
@ROUT C2blk `            b[@(k_)] = alpha*C@(c_)[@(r_)];`
      @endiif
      @iif beta = 1
@ROUT blk2C `            C@(c_)[@(r_)] += alpha*b[@(k_)];`
@ROUT C2blk `            b[@(k_)] += alpha*C@(c_)[@(r_)];`
      @endiif
      @iif beta = -1
@ROUT blk2C `            C@(c_)[@(r_)] = alpha*b[@(k_)] - C@(c_)[@(r_)];`
@ROUT C2blk `            b[@(k_)] = alpha*C@(c_)[@(r_)] - b[@(k_)];`
      @endiif
      @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `            C@(c_)[@(r_)] = beta*C@(c_)[@(r_)] + alpha*b[@(k_)];`
@ROUT C2blk `            b[@(k_)] = beta*b[@(k_)] + alpha*C@(c_)[@(r_)];`
      @endiif
   @endiif
@ENDPROC
@SKIP handles full block 
@BEGINPROC doBlockT m_ n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp k @(i) @(mu) * @(j) +
         @callproc doElementT @(i) @(j) @(k)  
         @iexp i @(i) 1 +
      @endiwhile
      @iif m_ = mu
            C@(j) += @(mu);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP handles full blocks when nu=na*mu 
@BEGINPROC doBlockTna m_ n_ mu_ inc_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp k @(i) @(mu_) * @(j) +
         @callproc doElementT @(i) @(j) @(k)  
         @iexp i @(i) 1 +
      @endiwhile
            C@(j) += @(inc_);
      @iexp j @(j) 1 +
   @endiwhile
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP handles partial block when nu = na*mu (na!=1) 
@BEGINPROC doDiBlockTna m_ n_ mu_ nu_ inc_ sc_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define t @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp t @(nu_) @(sc_) *
         @iexp t @(t) @(j) +
         @iexp k @(i) @(mu_) * @(j) +
@ROUT C2blk
         @iif i > @(t)
         p[@(k)] = 0.0;
         @endiif
@ROUT C2blk blk2C
         @iif i { @(t)
            @iexp t @(sc_) 1 +
            @iexp t @(t) @(nu_) *
            @iif i < @(t)
         @callproc doElementT @(i) @(j) @(k)  
            @endiif   
         @endiif
         @iexp i @(i) 1 +
      @endiwhile
            C@(j) += @(inc_);
      @iexp j @(j) 1 +
   @endiwhile
   @undef t
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP handles block with offset kk
@BEGINPROC doBlockTkk m_ n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp k @(i) @(mu) * @(j) +
         @callproc doElementT @(i) @(j) kk*@(nu)+@(k)  
         @iexp i @(i) 1 +
      @endiwhile
            C@(j) += @(m_);
      @iexp j @(j) 1 +
   @endiwhile
   @undef k
   @undef j
   @undef i
@ENDPROC
@skip handles diagonal block
@BEGINPROC doDiBlockT n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
         @iexp k @(i) @(mu) * @(j) +
@ROUT blk2C
         @iexp r @(i)
         @iexp c @(j)
         @iif j } i
      @callproc doElementT @(r) @(c) @(k)
         @endiif
@ROUT C2blk
         @iif j < i
            @iexp r @(j)
            @iexp c @(i)
         @endiif
         @iif j } i
            @iexp r @(i)
            @iexp c @(j)
         @endiif
      @callproc doElementT @(r) @(c) @(k)
@ROUT blk2C C2blk
         @iexp i @(i) 1 +
      @endiwhile
      @iif n_ = mu
            C@(j) += @(mu);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef k
   @undef j
   @undef i
@ENDPROC
@skip handles diagonal block with offset kk
@BEGINPROC doDiBlockTkk n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
         @iexp k @(i) @(mu) * @(j) +
@ROUT blk2C
         @iexp r @(i)
         @iexp c @(j)
         @iif j } i
      @callproc doElementT @(r) @(c) kk*@(nu)+@(k)
         @endiif
@ROUT C2blk
         @iif j < i
            @iexp r @(j)
            @iexp c @(i)
         @endiif
         @iif j } i
            @iexp r @(i)
            @iexp c @(j)
         @endiif
      @callproc doElementT @(r) @(c) kk*@(nu)+@(k)
@ROUT blk2C C2blk
         @iexp i @(i) 1 +
      @endiwhile
      @iif n_ = mu
            C@(j) += @(mu);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef k
   @undef j
   @undef i
@ENDPROC
@skip  handles cleanup of diagonal block when mu=ma*nu
@SKIP IN: mu, nu, beta, alpha,
@BEGINPROC doCuDiBlockT m_ n_ ma_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define sc @dum@
   @define t @dum@
   @iexp sc 0
   @iwhile sc < @(ma_)
      case @(sc):
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
         @iexp k @(i) @(m_) *
         @iexp t @(sc) @(n_) *
         @iexp k @(k) @(t) +
         @iexp k @(k) @(j) +
         @iif j } i
            @callproc doElementT @(i) @(j) @(k)
         @endiif
         @iexp i @(i) 1 +
      @endiwhile
         C@(j) += @(n_);
      @iexp j @(j) 1 +
   @endiwhile
         break;
      @iexp sc @(sc) 1 +
   @endiwhile
   @undef t
   @undef sc
   @undef k
   @undef j
   @undef i
@ENDPROC
@ROUT C2blk `#if 0`
#ifndef Mjoin
   #define Mjoin(pre, nam) my_join(pre, nam)
   #define my_join(pre, nam) pre ## nam
#endif
/*
 * The block is assumed to store L, this function does a transpose while
 * copying so that it is transferred with Upper portion of C
 */
void Mjoin(ATL_USERCPMM,_L2UT)
(
   const size_t M,      /* number of rows in A */
   const size_t N,      /* number of columns in A */
   @ROUT blk2C
   const @(typ) alpha,  /* scalar for b */
   const @(typ) *b,     /* matrix stored in @(mu)x@(nu)-major order */
   const @(typ) beta,   /* scalar for C */
   @(typ) *C,           /* matrix to be copied to access-major format */
   const size_t ldc     /* stride between row elements */
   @ROUT C2blk
   const @(typ) alpha,  /* scalar for C */
   const @(typ) *C,     /* matrix to be copied to access-major format */
   const size_t ldc,    /* stride between row elements */
   const @(typ) beta,   /* scalar for b */
   @(typ) *b            /* matrix stored in @(mu)x@(nu)-major order */
   @ROUT C2blk blk2C
)
{
   const unsigned int mf = M/@(mu), nf = N/@(nu);
   const unsigned int m = mf*@(mu), n = nf*@(nu), mr = M-m, nr = N-n;
   unsigned int i, j;
@iif na = 1      
   const size_t incC0 = ldc*@(nu);
@ROUT blk2C `   @declare "   @(typ) " n n ";"`
@ROUT C2blk `   @declare "   const @(typ) " n n ";"`
      *C0=C
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
@endiif
@iif na ! 1      
   const size_t incC0 = ldc*@(mu);
@ROUT blk2C `   @declare "   @(typ) " n n ";"`
@ROUT C2blk `   @declare "   const @(typ) " n n ";"`
      *C0=C
      @define j @1@
      @iwhile j < @(mu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
@endiif
@iif mEn = 0
   @iif ma ! 1
   unsigned int pansz = @(ma)*@(bs);
@ROUT blk2C `   const @(typ) *p = b;` 
@ROUT C2blk `   @(typ) *p = b;` 
   int kk;
   @endiif
@endiif
@iif na = 1
   for (j=0; j < nf; j++)
   {
      unsigned int incC = incC0 - (j+1)*@(nu);
      @iif mEn = 0
         @iif ma ! 1
      b = p;
      kk = j % @(ma);
         @endiif
      @endiif
      for (i=0; i < j; i++, b += @(bs))
      {
      @iif mEn = 1
         @callproc doBlockT @(mu) @(nu)
      @endiif
      @iif mEn = 0
         @iif ma ! 0
         @callproc doBlockTkk @(nu) @(nu) 
         @endiif
      @endiif
      }
   @iif mEn = 1
      @callproc doDiBlockT @(nu)
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
      b += @(bs);
   @endiif
   @iif mEn = 0
      @iif ma ! 1
      switch(j%@(ma))
      {
         @callproc doCuDiBlockT @(mu) @(nu) @(ma)
      default:;
      }
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
      p += ((j+1)%@(ma)==0? pansz: 0);
      pansz += ((j+1)%@(ma)==0? @(ma)*@(bs):0);
      @endiif
   @endiif
   }
@endiif
@iif na ! 1
   for (j=0; j < mf; j++)
   {
      size_t incC = incC0 - (j/@(na)+1)*@(nu);
      for (i=0; i < j/@(na); i++, b+=@(bs))
      {
         @callproc doBlockTna @(nu) @(mu) @(mu) @(nu)
      }
      switch(j%@(na))
      {
      @iexp n 0
      @iwhile n < @(na)
      case @(n):
         @callproc doDiBlockTna @(nu) @(mu) @(mu) @(mu) @(nu) @(n)
      break;
         @iexp n @(n) 1 +
      @endiwhile
      default:;
      }
   @iexp j 0
   @iwhile j < @(mu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
      b += @(bs);
   }
@endiif
@iif nu > 1
   @iif mEn = 1
   switch(nr)
   {
   @iexp n 1
   @iwhile n < @(nu)
   case @(n):
      for (i=0; i < mf; i++, b += @(bs))
      {
         @callproc doBlockT @(mu) @(n)
      }
      switch(mr)
      {
   @iexp m 1
   @iwhile m < @(mu)
      case @(m):
      @skip Assumption for sryk  m = n" 
      @callproc doDiBlockT @(m) 
      @iexp m @(m) 1 +
         break;
   @endiwhile
      default:;
      }
      break;
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
   @endiif
   @iif mEn = 0
      @iif ma ! 1
   b = p;
   kk = nf % @(ma);
   switch(nr)
   {
         @iexp n 1
         @iwhile n < @(nu)
   case @(n) :
      for (i=0; i < nf; i++, b+=@(bs))
      {
         @callproc doBlockTkk @(nu) @(n)
      }
         @callproc doDiBlockTkk @(n)
      break;
            @iexp n @(n) 1 +
         @endiwhile
   default:;
   }
      @endiif
   @endiif
@endiif
@iif mu > 1
   @iif na ! 1
   switch (mr)
   {
      @iexp n 1
      @iwhile n < @(mu)
   case @(n):
      for (i=0; i < nf; i++, b+=@(bs))
      {
      @callproc doBlockTna @(nu) @(n) @(mu) @(nu)
      }
      switch ( mf % @(na))
      {
            @iexp m 0 
            @iwhile m < na  
      case @(m):
            @callproc doDiBlockTna @(nu) @(n) @(mu) @(mu) @(nu) @(m)
         break;
               @iexp m @(m) 1  +
            @endiwhile
      default:;
      }
      break;
         @iexp n @(n) 1 +
      @endiwhile
   default:;
   }
   @endiif
@endiif
}
@ROUT C2blk `#endif`
@endiif
@SKIP ******************** Complex data type ***********************************
@PRE C Z
   @iexp betX 0 @(beta) ! 1 @(beta) ! & -1 @(beta) ! &
   @iexp alpX 0 @(alpha) ! 1 @(alpha) ! & -1 @(alpha) ! &
@SKIP blksz = ((mu*nu+vlen-1)/vlen)*vlen
@iexp bs @(vl) @(mu) @(nu) * @(vl) + -1 + / @(vl) *
/* HERE vl=@(vl), mu=@(mu), nu=@(nu) bs=@(bs)*/
@SKIP handles single element 
@BEGINPROC doElement c_ ir_ ii_ k_
         @iif alpha = 1
            @iif beta = 0
@ROUT blk2C 
            C@(c_)[@(ir_)] = pr[@(k_)];
            C@(c_)[@(ii_)] = pi[@(k_)];
@ROUT C2blk 
            pr[@(k_)] = C@(c_)[@(ir_)];
            pi[@(k_)] = C@(c_)[@(ii_)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            C@(c_)[@(ir_)] += pr[@(k_)];
            C@(c_)[@(ii_)] += pi[@(k_)];
@ROUT C2blk 
            pr[@(k_)] += C@(c_)[@(ir_)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            C@(c_)[@(ir_)] = pr[@(k_)] - C@(c_)[@(ir_)];
            C@(c_)[@(ii_)] = pi[@(k_)] - C@(c_)[@(ii_)];
@ROUT C2blk 
            pr[@(k_)] = C@(c_)[@(ir_)] - pr[@(k_)];
            pi[@(k_)] = C@(c_)[@(ii_)] - pi[@(k_)];
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            { 
               const register @(typ) rc=C@(c_)[@(ir_)], ic=C@(c_)[@(ii_)];
               register @(typ) rr=pr[@(k_)], ir=pi[@(k_)];
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               C@(c_)[@(ir_)] = rr;
               C@(c_)[@(ii_)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=pr[@(k_)], ic=pi[@(k_)];
               register @(typ) rr=C@(c_)[@(ir_)], ir=C@(c_)[@(ii_)];
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               pr[@(k_)] = rr;
               pi[@(k_)] = ic;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
         @iif alpha = -1
            @iif beta = 0
@ROUT blk2C 
            C@(c_)[@(ir_)] = -pr[@(k_)];
            C@(c_)[@(ii_)] = -pi[@(k_)];
@ROUT C2blk 
            pr[@(k_)] = -C@(c_)[@(ir_)];
            pi[@(k_)] = -C@(c_)[@(ii_)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            C@(c_)[@(ir_)] -= pr[@(k_)];
            C@(c_)[@(ii_)] -= pi[@(k_)];
@ROUT C2blk 
            pr[@(k_)] -= C@(c_)[@(ir_)];
            pi[@(k_)] -= C@(c_)[@(ii_)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            C@(c_)[@(ir_)] = -C@(c_)[@(ir_)] - pr[@(k_)];
            C@(c_)[@(ii_)] = -C@(c_)[@(ii_)] - pi[@(k_)];
@ROUT C2blk 
            pr[@(k_)] = -C@(c_)[@(ir_)] - pr[@(k_)];
            pi[@(k_)] = -C@(c_)[@(ii_)] - pi[@(k_)];
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            { 
               const register @(typ) rc=C@(c_)[@(ir_)], ic=C@(c_)[@(ii_)];
               register @(typ) rr = -pr[@(k_)], ir = -pi[@(k_)];
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               C@(c_)[@(ir_)] = rr;
               C@(c_)[@(ii_)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=pr[@(k_)], ic=pi[@(k_)];
               register @(typ) rr = -C@(c_)[@(ir_)], ir = -C@(c_)[@(ii_)];
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               pr[@(k_)] = rr;
               pi[@(k_)] = ic;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
         @iif @iexp @(alpha) 1 ! @(alpha) -1 ! &
            @iif beta = 0
@ROUT blk2C 
            { 
               const register @(typ) rc=pr[@(k_)], ic=pi[@(k_)];
               register @(typ) rr, ir;
               rr = rc * ra;
               ir = ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(c_)[@(ir_)] = rr;
               C@(c_)[@(ii_)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(c_)[@(ir_)], ic=C@(c_)[@(ii_)];
               register @(typ) rr, ir;
               rr  = rc * ra;
               ir  = ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               pr[@(k_)] = rr;
               pi[@(k_)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            { 
               const register @(typ) rc=pr[@(k_)], ic=pi[@(k_)];
               register @(typ) rr=C@(c_)[@(ir_)], ir=C@(c_)[@(ii_)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(c_)[@(ir_)] = rr;
               C@(c_)[@(ii_)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(c_)[@(ir_)], ic=C@(c_)[@(ii_)];
               register @(typ) rr=pr[@(k_)], ir=pi[@(k_)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               pr[@(k_)] = rr;
               pi[@(k_)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            { 
               const register @(typ) rc=pr[@(k_)], ic=pi[@(k_)];
               register @(typ) rr = -C@(c_)[@(ir_)], ir = -C@(c_)[@(ii_)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(c_)[@(ir_)] = rr;
               C@(c_)[@(ii_)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(c_)[@(ir_)], ic=C@(c_)[@(ii_)];
               register @(typ) rr = -pr[@(k_)], ir = -pi[@(k_)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               pr[@(k_)] = rr;
               pi[@(k_)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            {
               register @(typ) rc=C@(c_)[@(ir_)], ic=C@(c_)[@(ii_)];
               register @(typ) rB=pr[@(k_)], iB=pi[@(k_)], r0, i0, r1, i1;
               r0  = rb * rc;
               r1  = ra * rB;
               i0  = rb * ic;
               i1  = ra * iB;
               r0 -= ib * ic;
               i1 += ib * rc;
               r1 -= ia * iB;
               i1 += ia * rB;
               C@(c_)[@(ir_)] = r0 + r1;
               C@(c_)[@(ii_)] = i0 + i1;
            }
@ROUT C2blk 
            {
               register @(typ) rB=C@(c_)[@(ir_)], iB=C@(c_)[@(ii_)];
               register @(typ) rc=pr[@(k_)], ic=pi[@(k_)], r0, i0, r1, i1;
               r0  = rb * rc;
               r1  = ra * rB;
               i0  = rb * ic;
               i1  = ra * iB;
               r0 -= ib * ic;
               i1 += ib * rc;
               r1 -= ia * iB;
               i1 += ia * rB;
               pr[@(k_)] = r0 + r1;
               pi[@(k_)] = i0 + i1;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
@ENDPROC
@SKIP handles diagonal block when mu=nu
@SKIP IN: mu, nu, beta, alpha
@BEGINPROC doDiBlock n_
   @define i @dum@
   @define ir @dum@
   @define ii @dum@
   @define j @dum@
   @define k @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
@ROUT C2blk 
         @iif j > i
            @iexp ir @(j) @(j) +
            @define h @@(i)@
         @endiif
         @iif j { i
            @iexp ir @(i) @(i) +
            @define h @@(j)@
         @endiif
         @iexp ii @(ir) 1 +
         @iexp k @(j) @(mu) * @(i) +
@ROUT blk2C 
         @iexp ir @(i) @(i) +
         @iexp ii @(ir) 1 +
         @iexp k @(j) @(mu) * @(i) +
         @iif j { i
@ROUT blk2C C2blk
         @iif alpha = 1
            @iif beta = 0
@ROUT blk2C 
            C@(j)[@(ir)] = pr[@(k)];  
            C@(j)[@(ii)] = pi[@(k)];
@ROUT C2blk 
            pr[@(k)] = C@(h)[@(ir)];
            pi[@(k)] = C@(h)[@(ii)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            C@(j)[@(ir)] += pr[@(k)];
            C@(j)[@(ii)] += pi[@(k)];
@ROUT C2blk 
            pr[@(k)] += C@(h)[@(ir)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            C@(j)[@(ir)] = pr[@(k)] - C@(j)[@(ir)];
            C@(j)[@(ii)] = pi[@(k)] - C@(j)[@(ii)];
@ROUT C2blk 
            pr[@(k)] = C@(h)[@(ir)] - pr[@(k)];
            pi[@(k)] = C@(h)[@(ii)] - pi[@(k)];
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            { 
               const register @(typ) rc=C@(j)[@(ir)], ic=C@(j)[@(ii)];
               register @(typ) rr=pr[@(k)], ir=pi[@(k)];
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               C@(j)[@(ir)] = rr;
               C@(j)[@(ii)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=pr[@(k)], ic=pi[@(k)];
               register @(typ) rr=C@(h)[@(ir)], ir=C@(h)[@(ii)];
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               pr[@(k)] = rr;
               pi[@(k)] = ic;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
         @iif alpha = -1
            @iif beta = 0
@ROUT blk2C 
            C@(j)[@(ir)] = -pr[@(k)];
            C@(j)[@(ii)] = -pi[@(k)];
@ROUT C2blk 
            pr[@(k)] = -C@(h)[@(ir)];
            pi[@(k)] = -C@(h)[@(ii)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            C@(j)[@(ir)] -= pr[@(k)];
            C@(j)[@(ii)] -= pi[@(k)];
@ROUT C2blk 
            pr[@(k)] -= C@(h)[@(ir)];
            pi[@(k)] -= C@(h)[@(ii)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            C@(j)[@(ir)] = -C@(j)[@(ir)] - pr[@(k)];
            C@(j)[@(ii)] = -C@(j)[@(ii)] - pi[@(k)];
@ROUT C2blk 
            pr[@(k)] = -C@(h)[@(ir)] - pr[@(k)];
            pi[@(k)] = -C@(h)[@(ii)] - pi[@(k)];
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            { 
               const register @(typ) rc=C@(j)[@(ir)], ic=C@(j)[@(ii)];
               register @(typ) rr = -pr[@(k)], ir = -pi[@(k)];
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               C@(j)[@(ir)] = rr;
               C@(j)[@(ii)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=pr[@(k)], ic=pi[@(k)];
               register @(typ) rr = -C@(h)[@(ir)], ir = -C@(h)[@(ii)];
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               pr[@(k)] = rr;
               pi[@(k)] = ic;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
         @iif @iexp @(alpha) 1 ! @(alpha) -1 ! &
            @iif beta = 0
@ROUT blk2C 
            { 
               const register @(typ) rc=pr[@(k)], ic=pi[@(k)];
               register @(typ) rr, ir;
               rr = rc * ra;
               ir = ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(j)[@(ir)] = rr;
               C@(j)[@(ii)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(h)[@(ir)], ic=C@(h)[@(ii)];
               register @(typ) rr, ir;
               rr  = rc * ra;
               ir  = ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               pr[@(k)] = rr;
               pi[@(k)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            { 
               const register @(typ) rc=pr[@(k)], ic=pi[@(k)];
               register @(typ) rr=C@(j)[@(ir)], ir=C@(j)[@(ii)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(j)[@(ir)] = rr;
               C@(j)[@(ii)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(h)[@(ir)], ic=C@(h)[@(ii)];
               register @(typ) rr=pr[@(k)], ir=pi[@(k)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               pr[@(k)] = rr;
               pi[@(k)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            { 
               const register @(typ) rc=pr[@(k)], ic=pi[@(k)];
               register @(typ) rr = -C@(j)[@(ir)], ir = -C@(j)[@(ii)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(j)[@(ir)] = rr;
               C@(j)[@(ii)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(h)[@(ir)], ic=C@(h)[@(ii)];
               const register @(typ) rr = -pr[@(k)], ir = -pi[@(k)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               pr[@(k)] = rr;
               pi[@(k)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            {
               register @(typ) rc=C@(j)[@(ir)], ic=C@(j)[@(ii)];
               register @(typ) rB=pr[@(k)], iB=pi[@(k)], r0, i0, r1, i1;
               r0  = rb * rc;
               r1  = ra * rB;
               i0  = rb * ic;
               i1  = ra * iB;
               r0 -= ib * ic;
               i1 += ib * rc;
               r1 -= ia * iB;
               i1 += ia * rB;
               C@(j)[@(ir)] = r0 + r1;
               C@(j)[@(ii)] = i0 + i1;
            }
@ROUT C2blk 
            {
               register @(typ) rB=C@(h)[@(ir)], iB=C@(h)[@(ii)];
               register @(typ) rc=pr[@(k)], ic=pi[@(k)], r0, i0, r1, i1;
               r0  = rb * rc;
               r1  = ra * rB;
               i0  = rb * ic;
               i1  = ra * iB;
               r0 -= ib * ic;
               i1 += ib * rc;
               r1 -= ia * iB;
               i1 += ia * rB;
               pr[@(k)] = r0 + r1;
               pi[@(k)] = i0 + i1;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
@ROUT blk2C
         @endiif
@ROUT blk2C C2blk
         @iexp i @(i) 1 +
      @endiwhile
      @iexp i @(mu) @(mu) +
      @iif n_ = mu
            C@(j) += @(i);
      @endiif
@ROUT C2blk `      @undef h`
      @iexp j @(j) 1 +
   @endiwhile
   @undef k
   @undef ii
   @undef ir
   @undef j
   @undef i 
@ENDPROC
@SKIP handles full block
@BEGINPROC doBlock m_ n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define ir @dum@
   @define ii @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp ir @(i) @(i) +
         @iexp ii @(ir) 1 +
         @iexp k @(j) @(mu) * @(i) +
         @callproc doElement @(j) @(ir) @(ii) @(k) 
         @iexp i @(i) 1 +
      @endiwhile
      @iexp i @(mu) @(mu) +
      @iif m_ = mu
            C@(j) += @(i);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef ii
   @undef ir
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP handles diagonal subblocks when mu=ma*nu
@SKIP IN: mu, nu, beta, alpha
@BEGINPROC doDiBlockmn m_ n_ ma_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define t @dum@
   @define sc @dum@
   @define ir @dum@
   @define ii @dum@
   @define jj @dum@
      switch (j%@(ma_))
      {
      @iexp sc 0
      @iwhile sc < @(ma_)
      case @(sc):
         @iexp j 0
         @iwhile j < @(n_)  
            @iexp i 0
            @iwhile i < @(m_) 
               @iexp k @(j) @(mu) * @(i) +
               @iexp t @(nu) @(sc) *
               @iexp t @(t) @(j) +
               @iif i < @(t) 
@ROUT C2blk    
                  @iexp jj @(m_) -1 +    
                  @iexp ir @(jj) @(jj) + 
                  @iexp ii @(ir) 1 + 
                  @callproc doElement @(j) @(ir) @(ii) @(k) 
@ROUT C2blk blk2C
               @endiif
               @iif i } @(t)
                  @iexp ir @(i) @(i) + 
                  @iexp ii @(ir) 1 + 
                  @callproc doElement @(j) @(ir) @(ii) @(k)
               @endiif
               @iexp i @(i) 1 +
            @endiwhile
         @iexp ir @(m_) @(m_) +
         @skip C@(j) += @(m_);
         C@(j) += @(ir);
            @iexp j @(j) 1 +
         @endiwhile
         break;
         @iexp sc @(sc) 1 +
      @endiwhile
      default:;
      }
   @undef jj
   @undef ii 
   @undef ir 
   @undef sc
   @undef t
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP diagonal block when nu > mu and nu = na * mu
@BEGINPROC doDikkBlockna n_ mul_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define c @dum@
   @define r @dum@
   @define m @dum@
   @define ir @dum@
   @define ii @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
         @iexp k @(j) @(mu) * @(i) +
@ROUT blk2C
         @iexp r @(i)
         @iexp c @(j)
         @iif j { i
@ROUT C2blk
         @iif j > i
            @iexp r @(j)
            @iexp c @(i)
         @endiif
         @iif j { i
            @iexp r @(i)
            @iexp c @(j)
         @endiif
@ROUT blk2C C2blk
         @iexp ir @(r) @(r) + 
         @iexp ii @(ir) 1 + 
         @callproc doElement @(c) @(ir) @(ii) @(k)+kk*@(mul_) 
@ROUT blk2C
         @endiif
@ROUT blk2C C2blk
         @iexp i @(i) 1 +
      @endiwhile
      @iif n_ = mu
            @iexp ir @(mu) @(mu) +
            @skip C@(j) += @(mu);
            C@(j) += @(ir);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef ii
   @undef ir
   @undef m
   @undef r
   @undef c
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP full blocks with multiplication 
@BEGINPROC donaBlock m_ n_ mn_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define m @dum@
   @define ir @dum@
   @define ii @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp k @(j) @(mu) * @(i) +
         @iexp ir @(i) @(i) + 
         @iexp ii @(ir) 1 + 
         @callproc doElement @(j) @(ir) @(ii) @(k)+kk*@(mn_) 
         @iexp i @(i) 1 +
      @endiwhile
      @iif m_ = mu
         @iexp ir @(mu) @(mu) + 
            C@(j) += @(ir);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef ii
   @undef ir
   @undef m
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP handles cleanup of diagonal subblocks when mu=ma*nu
@SKIP IN: mu, nu, beta, alpha,
@BEGINPROC doCuDiBlockmn m_ n_ ma_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define jj @dum@
   @define t @dum@
   @define sc @dum@
   @define m @dum@
      unsigned int kk;
      switch (j%@(ma_))
      {
      @iexp m @(ma_) -1 +
      @iexp sc 0
      @iwhile sc < @(m)
      case @(sc):
         @iexp j 0
         @iwhile j < @(n_)  
            @iexp i 0 
            @iwhile i < @(m_) 
               @iexp k @(j) @(mu) * @(i) +
               @iexp t @(nu) @(sc) *
               @iexp t @(t) @(j) +
@ROUT C2blk    
               @iif i < @(t) 
               @iexp jj @(i) 1 +    
            pr[@(k)] = 0.0;
            pi[@(k)] = 0.0;
               @endiif
@ROUT C2blk blk2C
               @iif i } @(t)
                  @skip "upper limit"
                  @iexp t @(sc) 1 +
                  @iexp t @(t) @(nu) *
                  @iif i < @(t)
                     @iexp ir @(i) @(i) + 
                     @iexp ii @(ir) 1 + 
            @callproc doElement @(j) @(ir) @(ii) @(k)
                  @endiif
               @endiif
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
            @skip "now from nu to mu "
            @iexp jj @(sc) 1 +
            @iexp jj @(jj) @(n_) *
            for (kk=@(jj); kk < mr; kk++ )
            {
               @iexp jj 0
               @iwhile jj < @(n_)
                  @iexp t @(jj) @(m_) * 
                  @callproc doElement @(jj) (2*kk) (2*kk+1) @(t)+kk
                  @iexp jj @(jj) 1 +
               @endiwhile
            }
            break;
         @iexp sc @(sc) 1 +
      @endiwhile
      default:;
      }
   @undef m
   @undef sc
   @undef t
   @undef jj
   @undef k
   @undef j
   @undef i
@ENDPROC
@ROUT blk2C C2blk
@iif cpvl = 1
void @(rtnm)
(
   const size_t M,      /* number of rows in A */
   const size_t N,      /* number of columns in A */
   const @(typ) *alpha, /* scalar for b */
   @ROUT blk2C
   const @(typ) *rC,    /* real block stored in @(mu)x@(nu)-major order */
   const @(typ) *iC,    /* imag block stored in @(mu)x@(nu)-major order */
   const @(typ) *beta,  /* scalar for C */
   @(typ) *C,           /* matrix to be copied to access-major format */
   const size_t ldc     /* stride between row elements */
   @ROUT C2blk
   const @(typ) *C,     /* matrix to be copied to access-major format */
   const size_t ldc,    /* stride between row elements */
   const @(typ) *beta,  /* scalar for C */
   @(typ) *rC,          /* real block stored in @(mu)x@(nu)-major order */
   @(typ) *iC           /* imag block stored in @(mu)x@(nu)-major order */
   @ROUT C2blk blk2C
)
@endiif
@iif cpvl > 1
static INLINE void a2c_1(const size_t M, const size_t N, const @(typ) alpha, 
                         const @(typ) *b, const SCALAR beta, 
                         @(typ) *C, ATL_CSZT ldc)
@endiif
{
@SKIP *********************** GEMM copy: complex type **************************
@iif TRI = 0 
   const unsigned int mf = M/@(mu), nf = N/@(nu);
   const unsigned int m = mf*@(mu), n = nf*@(nu), mr = M-m, nr = N-n;
   const unsigned int pansz = (nr) ? (nf+1)*@(bs) : nf*@(bs); /* bs=@(bs) */
   const size_t incC = (ldc*@(nu) - m)<<1, ldc2 = ldc+ldc;
   unsigned int i, j;
   @iif alpX ! 0
   const register @(typ) ra=(*alpha), ia=alpha[1];
   @endiif
   @iif betX ! 0
   const register @(typ) rb=(*beta), ib=beta[1];
   @endiif
@ROUT blk2C `   @declare "   @(typ) " n n ";"`
@ROUT C2blk `   @declare "   const @(typ) " n n ";"`
      *C0=C
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc2
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
   for (j=nf; j; j--, rC += @(bs), iC += @(bs))
   {
@ROUT blk2C `      const @(typ) *pr = rC, *pi = iC;`
@ROUT C2blk `      @(typ) *pr = rC, *pi = iC;`
@iif TRI = 1
      unsigned int psz = pansz+@(bs), incC = incC0 - (mf-j)*(@(mu)+@(mu));
      @callproc doDiBlock @(nu)
      pr += pansz; pi += pansz;
      for (i=j+1; i < mf; i++, pr += psz, pi += psz, psz += @(bs))
@endiif
      for (i=mf; i; i--, pr += pansz, pi += pansz)
      {
         @callproc doBlock @(mu) @(nu)
      }
      switch(mr)
      {
   @iexp m 1
   @iwhile m < @(mu)
      case @(m):
      @callproc doBlock @(m) @(nu)
      @iexp m @(m) 1 +
         break;
   @endiwhile
      default:;
      }
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
   }
@iif nu > 1
   switch(nr)
   {
@ROUT blk2C `      const @(typ) *pr, *pi;`
@ROUT C2blk `      @(typ) *pr, *pi;`
   @iexp n 1
   @iwhile n < @(nu)
   case @(n):
      pr = rC; pi = iC;
      for (i=0; i < mf; i++, pr += pansz, pi += pansz)
      {
         @callproc doBlock @(mu) @(n)
      }
      switch(mr)
      {
   @iexp m 1
   @iwhile m < @(mu)
      case @(m):
      @callproc doBlock @(m) @(n)
      @iexp m @(m) 1 +
         break;
   @endiwhile
      default:;
      }
      break;
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
@endiif
@endiif
@SKIP ***************** SYRK copy: complex type ********************************
@iif TRI = 1
   const unsigned int mf = M/@(mu), nf = N/@(nu);
   const unsigned int m = mf*@(mu), n = nf*@(nu), mr = M-m, nr = N-n;
   @iif mEn = 1
   unsigned int pansz = @(bs);
   const size_t ldc2 = ldc+ldc, incC0 = (ldc2+2)*@(nu);
   @endiif
   @iif mEn = 0
      @skip "*** case mu = ma*nu"
      @iif ma ! 1
   unsigned int pansz = @(bs)*@(ma);
   const unsigned int manf = (N/(@(nu)*@(ma)))*@(ma);
   const unsigned int manr = nf - manf;
   const size_t ldc2 = ldc+ldc, incC0 = ldc2*@(nu);
      @endiif 
      @skip "*** special case for nu = na * mu"
      @iif na ! 1
   unsigned int pansz = @(bs);
   const size_t ldc2 = ldc+ldc, incC0 = (ldc2+2)*@(nu);
   const unsigned int mnf = N/@(mu);
   const unsigned int mnr = N - (mnf*@(mu));
   unsigned int kk; 
      @endiif
   @endiif
   unsigned int i, j;
   @iif alpX ! 0
   const register @(typ) ra=(*alpha), ia=alpha[1];
   @endiif
   @iif betX ! 0
   const register @(typ) rb=(*beta), ib=beta[1];
   @endiif
@ROUT blk2C `   @declare "   @(typ) " n n ";"`
@ROUT C2blk `   @declare "   const @(typ) " n n ";"`
      *C0=C
@iif na = 1
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc2
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
@endiif
@iif na ! 1
      @define j @1@
      @iwhile j < @(mu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc2
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
@endiif
   @iif mEn = 1
   for (j=0; j < nf; j++)
   @endiif
   @iif mEn = 0
      @iif ma ! 1
   size_t incC;
   for (j=0; j < manf; j++)
      @endiif
      @iif na ! 1
   for (j=0; j < mnf; j++)
      @endiif
   @endiif
   {
@ROUT blk2C `      const @(typ) *pr = rC, *pi = iC;`
@ROUT C2blk `      @(typ) *pr = rC, *pi = iC;`
   @iif mEn = 1
      unsigned int psz = pansz+@(bs), incC = incC0 - (mf-j)*(@(mu)+@(mu));
      @callproc doDiBlock @(nu)
      pr += pansz; pi += pansz;
      for (i=j+1; i < mf; i++, pr += psz, pi += psz, psz += @(bs))
   @endiif
   @iif mEn = 0
      @iif ma ! 1
      unsigned int psz = pansz + @(ma)*@(bs); 
      incC = incC0 - (mf-(j+1)/@(ma))*(@(mu)+@(mu));
      @callproc doDiBlockmn @(mu) @(nu) @(ma)
      pr += pansz; pi += pansz;
      for (i=j/@(ma)+1; i < mf; i++, pr += psz, pi += psz, psz += @(bs)*@(ma))
      @endiif
      @iif na ! 1
      unsigned int psz = pansz, incC = incC0 - (mf-j)*@(mu);
      kk = j % @(na);
      @iexp mumu @(mu) @(mu) *
      @callproc doDikkBlockna @(mu) @(mumu)
      pr += pansz; pi += pansz;
      for (i=j+1; i < mf; i++, pr += psz, pi += psz )
      @endiif
   @endiif
@iif na = 1
      {
         @callproc doBlock @(mu) @(nu)
      }
@endiif
@iif na ! 1
      {
         @callproc donaBlock @(mu) @(mu) @(mumu)
         psz += ((i%@(na))==0?@(bs):0);
      }
@endiif
      switch(mr)
      {
   @iexp m 1
   @iwhile m < @(mu)
      case @(m):
@iif na = 1
      @callproc doBlock @(m) @(nu)
@endiif
@iif na ! 1
      @callproc donaBlock @(m) @(mu) @(mumu)
@endiif
      @iexp m @(m) 1 +
         break;
   @endiwhile
      default:;
      }
@iif na = 1
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
@endiif
@iif na ! 1
   @iexp j 0
   @iwhile j < @(mu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
@endiif
   @iif mEn = 1
      pansz += @(bs);
      rC += pansz;
      iC += pansz;
   @endiif
   @iif mEn = 0
      @iif ma ! 1
      rC += ((j+1)% @(ma))==0 ? pansz+@(bs) : @(bs);
      iC += ((j+1)% @(ma))==0 ? pansz+@(bs) : @(bs);
      if ( (j+1) % @(ma) == 0)
         pansz += @(ma)*@(bs);
      @endiif
      @iif na ! 1
      pansz += ((j+1)%@(na)==0?@(bs):0);
      rC += pansz;
      iC += pansz;
      @endiif
   @endiif
   }
   @SKIP "Remainder of manr = nf - manf " 
   @iif mEn = 0
      @iif ma ! 1
   for (j=manf; j < nf; j++)
   {
@ROUT blk2C `      const @(typ) *pr = rC, *pi = iC;`
@ROUT C2blk `      @(typ) *pr = rC, *pi = iC;`
      unsigned int psz = pansz + @(ma)*@(bs), 
                         incC = incC0 - ((mf-(j+1)/@(ma))<<1)*@(mu);
         @callproc doCuDiBlockmn @(mu) @(nu) @(ma)
      pr += pansz;
      pi += pansz;
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
      rC += ((j+1)% @(ma))==0 ? pansz+@(bs) : @(bs);
      iC += ((j+1)% @(ma))==0 ? pansz+@(bs) : @(bs);
      if ( (j+1) % @(ma) == 0)
         pansz += @(ma)*@(bs);
   }
         @endiif
      @endiif
@iif na = 1
   @iif nu > 1
   switch(nr)
   {
@ROUT blk2C `      const @(typ) *pr, *pi;`
@ROUT C2blk `      @(typ) *pr, *pi;`
   @iexp n 1
   @iwhile n < @(nu)
   case @(n):
      pr = rC; pi = iC;
   @iif mEn = 1
      @callproc doDiBlock @(n)
   @endiif
   @iif mEn = 0
      @iif ma ! 1
         pr += mr - nr; pi += mr - nr; 
         @iexp k 0
         @iwhile k < @(n)
            @skip ---C@(k) += mr-nr;
            C@(k) += ((mr-nr)<<1);
            @iexp k @(k) 1 +
         @endiwhile
         @skip "for nr cleanup, it works like mu=nu"
         @callproc doDiBlock @(n)
      @endiif
   @endiif
      break;
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
   @endiif
@endiif
@iif na ! 1
   @iif mu > 1
   kk = mnf % @(na);
   switch(mnr)
   {
@ROUT blk2C `      const @(typ) *pr, *pi;`
@ROUT C2blk `      @(typ) *pr, *pi;`
   @iexp n 1
   @iwhile n < @(mu)
   case @(n):
      pr= rC;
      pi =iC;
      @callproc doDikkBlockna @(n) @(mumu)
         break;
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
   @endiif
@endiif
@endiif
}
@SKIP ***************** SYRK L2UT : complex type *******************************
@iif TRI = 1
@SKIP handles single element 
@BEGINPROC doElementT c_ ir_ ii_ k_ 
         @iif alpha = 1
            @iif beta = 0
@ROUT blk2C 
            C@(c_)[@(ir_)] = rC[@(k_)];
            #ifdef Conj_
               C@(c_)[@(ii_)] = -iC[@(k_)];
            #else
               C@(c_)[@(ii_)] = iC[@(k_)];
            #endif
@ROUT C2blk 
            rC[@(k_)] = C@(c_)[@(ir_)];
            #ifdef Conj_
               iC[@(k_)] = -C@(c_)[@(ii_)];
            #else
               iC[@(k_)] = C@(c_)[@(ii_)];
            #endif
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            C@(c_)[@(ir_)] += rC[@(k_)];
            #ifdef Conj_
               C@(c_)[@(ii_)] -= iC[@(k_)];
            #else
               C@(c_)[@(ii_)] += iC[@(k_)];
            #endif
@ROUT C2blk 
            rC[@(k_)] += C@(c_)[@(ir_)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            C@(c_)[@(ir_)] = rC[@(k_)] - C@(c_)[@(ir_)];
            #ifdef Conj_
               C@(c_)[@(ii_)] = -iC[@(k_)] - C@(c_)[@(ii_)];
            #else
               C@(c_)[@(ii_)] = iC[@(k_)] - C@(c_)[@(ii_)];
            #endif
@ROUT C2blk 
            rC[@(k_)] = C@(c_)[@(ir_)] - rC[@(k_)];
            #ifdef Conj_
               iC[@(k_)] = C@(c_)[@(ii_)] + iC[@(k_)];
            #else
               iC[@(k_)] = C@(c_)[@(ii_)] - iC[@(k_)];
            #endif
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            { 
               const register @(typ) rc=C@(c_)[@(ir_)], ic=C@(c_)[@(ii_)];
               register @(typ) rr=rC[@(k_)];
               #ifdef Conj_
                  register @(typ) ir = -iC[@(k_)];
               #else
                  register @(typ) ir =  iC[@(k_)];
               #endif
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               C@(c_)[@(ir_)] = rr;
               C@(c_)[@(ii_)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=rC[@(k_)], ic=iC[@(k_)];
               register @(typ) rr=C@(c_)[@(ir_)];
               #ifdef Conj_
                  register @(typ) ir = -C@(c_)[@(ii_)];
               #else
                  register @(typ) ir =  C@(c_)[@(ii_)];
               #endif
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               rC[@(k_)] = rr;
               iC[@(k_)] = ic;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
         @iif alpha = -1
            @iif beta = 0
@ROUT blk2C 
            C@(c_)[@(ir_)] = -rC[@(k_)];
            #ifdef Conj_
               C@(c_)[@(ii_)] = iC[@(k_)];
            #else
               C@(c_)[@(ii_)] = -iC[@(k_)];
            #endif
@ROUT C2blk 
            rC[@(k_)] = -C@(c_)[@(ir_)];
            #ifdef Conj_
               iC[@(k_)] = C@(c_)[@(ii_)];
            #else
               iC[@(k_)] = -C@(c_)[@(ii_)];
            #endif
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            C@(c_)[@(ir_)] -= rC[@(k_)];
            #ifdef Conj_
               C@(c_)[@(ii_)] += iC[@(k_)];
            #else
               C@(c_)[@(ii_)] -= iC[@(k_)];
            #endif
@ROUT C2blk 
            rC[@(k_)] -= C@(c_)[@(ir_)];
            #ifdef Conj_
               iC[@(k_)] += C@(c_)[@(ii_)];
            #else
               iC[@(k_)] -= C@(c_)[@(ii_)];
            #endif
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            C@(c_)[@(ir_)] = -C@(c_)[@(ir_)] - rC[@(k_)];
            #ifdef Conj_
               C@(c_)[@(ii_)] = iC[@(k_)] - C@(c_)[@(ii_)];
            #else
               C@(c_)[@(ii_)] = -C@(c_)[@(ii_)] - iC[@(k_)];
            #endif
@ROUT C2blk 
            rC[@(k_)] = -C@(c_)[@(ir_)] - rC[@(k_)];
            #ifdef Conj_
               iC[@(k_)] = C@(c_)[@(ii_)] - iC[@(k_)];
            #else
               iC[@(k_)] = -C@(c_)[@(ii_)] - iC[@(k_)];
            #endif
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            { 
               const register @(typ) rc=C@(c_)[@(ir_)], ic=C@(c_)[@(ii_)];
               register @(typ) rr = -rC[@(k_)];
               #ifdef Conj_
                  register @(typ) ir = iC[@(k_)];
               #else
                  register @(typ) ir = -iC[@(k_)];
               #endif
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               C@(c_)[@(ir_)] = rr;
               C@(c_)[@(ii_)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=rC[@(k_)], ic=iC[@(k_)];
               register @(typ) rr = -C@(c_)[@(ir_)];
               #ifdef Conj_
                  register @(typ) ir =  C@(c_)[@(ii_)];
               #else
                  register @(typ) ir = -C@(c_)[@(ii_)];
               #endif
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               rC[@(k_)] = rr;
               iC[@(k_)] = ic;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
         @iif @iexp @(alpha) 1 ! @(alpha) -1 ! &
            @iif beta = 0
@ROUT blk2C 
            { 
               const register @(typ) rc=rC[@(k_)];
               #ifdef Conj_
                  const register @(typ) ic = -iC[@(k_)];
               #else
                  const register @(typ) ic =  iC[@(k_)];
               #endif
               register @(typ) rr, ir;
               rr = rc * ra;
               ir = ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(c_)[@(ir_)] = rr;
               C@(c_)[@(ii_)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(c_)[@(ir_)];
               #ifdef Conj_
                  const register @(typ) ic = -C@(c_)[@(ii_)];
               #else
                  const register @(typ) ic =  C@(c_)[@(ii_)];
               #endif
               register @(typ) rr, ir;
               rr  = rc * ra;
               ir  = ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               rC[@(k_)] = rr;
               iC[@(k_)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            { 
               const register @(typ) rc=rC[@(k_)];
               #ifdef Conj_
                  const register @(typ) ic = -iC[@(k_)];
               #else
                  const register @(typ) ic =  iC[@(k_)];
               #endif
               register @(typ) rr=C@(c_)[@(ir_)], ir=C@(c_)[@(ii_)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(c_)[@(ir_)] = rr;
               C@(c_)[@(ii_)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(c_)[@(ir_)];
               #ifdef Conj_
                  const register @(typ) ic = -C@(c_)[@(ii_)];
               #else
                  const register @(typ) ic =  C@(c_)[@(ii_)];
               #endif
               register @(typ) rr=rC[@(k_)], ir=iC[@(k_)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               rC[@(k_)] = rr;
               iC[@(k_)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            { 
               const register @(typ) rc=rC[@(k_)];
               #ifdef Conj_
                  const register @(typ) ic = -iC[@(k_)];
               #else
                  const register @(typ) ic =  iC[@(k_)];
               #endif
               register @(typ) rr = -C@(c_)[@(ir_)], ir = -C@(c_)[@(ii_)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(c_)[@(ir_)] = rr;
               C@(c_)[@(ii_)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(c_)[@(ir_)];
               #ifdef Conj_
                  const register @(typ) ic = -C@(c_)[@(ii_)];
               #else
                  const register @(typ) ic =  C@(c_)[@(ii_)];
               #endif
               register @(typ) rr = -rC[@(k_)], ir = -iC[@(k_)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               rC[@(k_)] = rr;
               iC[@(k_)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            {
               register @(typ) rc=C@(c_)[@(ir_)], ic=C@(c_)[@(ii_)];
               register @(typ) rB=rC[@(k_)], r0, i0, r1, i1;
               #ifdef Conj_
                  register @(typ) iB = -iC[@(k_)];
               #else
                  register @(typ) iB =  iC[@(k_)];
               #endif
               r0  = rb * rc;
               r1  = ra * rB;
               i0  = rb * ic;
               i1  = ra * iB;
               r0 -= ib * ic;
               i1 += ib * rc;
               r1 -= ia * iB;
               i1 += ia * rB;
               C@(c_)[@(ir_)] = r0 + r1;
               C@(c_)[@(ii_)] = i0 + i1;
            }
@ROUT C2blk 
            {
               register @(typ) rB=C@(c_)[@(ir_)];
               #ifdef Conj_
                  register @(typ) iB = -C@(c_)[@(ii_)];
               #else
                  register @(typ) iB =  C@(c_)[@(ii_)];
               #endif
               register @(typ) rc=rC[@(k_)], ic=iC[@(k_)], r0, i0, r1, i1;
               r0  = rb * rc;
               r1  = ra * rB;
               i0  = rb * ic;
               i1  = ra * iB;
               r0 -= ib * ic;
               i1 += ib * rc;
               r1 -= ia * iB;
               i1 += ia * rB;
               rC[@(k_)] = r0 + r1;
               iC[@(k_)] = i0 + i1;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
@ENDPROC
@SKIP handles full subblock
@BEGINPROC doBlockT m_ n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define ir @dum@
   @define ii @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp ir @(i) @(i) +
         @iexp ii @(ir) 1 +
         @iexp k @(i) @(mu) * @(j) +
            @callproc doElementT @(j) @(ir) @(ii) @(k) 
         @iexp i @(i) 1 +
      @endiwhile
      @iexp i @(mu) @(mu) +
      @iif m_ = mu
            C@(j) += @(i);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef ii
   @undef ir
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP hanldes blocks with offset kk
@BEGINPROC doBlockTkk m_ n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define ir @dum@
   @define ii @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp ir @(i) @(i) +
         @iexp ii @(ir) 1 +
         @iexp k @(i) @(mu) * @(j) +
         @callproc doElementT @(j) @(ir) @(ii) kk*@(nu)+@(k)  
         @iexp i @(i) 1 +
      @endiwhile
      @iexp i @(m_) @(m_) +
            C@(j) += @(i);
      @iexp j @(j) 1 +
   @endiwhile
   @undef ii
   @undef ir
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP handles full block when nu=na*mu
@BEGINPROC doBlockTna m_ n_ mu_ inc_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define ir @dum@
   @define ii @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp ir @(i) @(i) +
         @iexp ii @(ir) 1 +
         @iexp k @(i) @(mu_) * @(j) +
         @callproc doElementT @(j) @(ir) @(ii) @(k)  
         @iexp i @(i) 1 +
      @endiwhile
      @iexp i @(inc_) @(inc_) +
            C@(j) += @(i);
      @iexp j @(j) 1 +
   @endiwhile
   @undef ii
   @undef ir
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP handles diagonal blocks
@BEGINPROC doDiBlockT n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define ir @dum@
   @define ii @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
@ROUT C2blk 
         @iif j < i
            @iexp ir @(j) @(j) +
            @define h @@(i)@
         @endiif
         @iif j } i
            @iexp ir @(i) @(i) +
            @define h @@(j)@
         @endiif
         @iexp ii @(ir) 1 +
         @iexp k @(i) @(mu) * @(j) +
            @callproc doElementT @(h) @(ir) @(ii) @(k) 
@ROUT blk2C 
         @iexp ir @(i) @(i) +
         @iexp ii @(ir) 1 +
         @iexp k @(i) @(mu) * @(j) +
         @iif j } i
            @callproc doElementT @(j) @(ir) @(ii) @(k) 
         @endiif
@ROUT blk2C C2blk
         @iexp i @(i) 1 +
      @endiwhile
      @iif n_ = mu
         @iexp i @(mu) @(mu) +
            C@(j) += @(i);
      @endiif
@ROUT C2blk `      @undef h`
      @iexp j @(j) 1 +
   @endiwhile
   @undef ii
   @undef ir
   @undef k
   @undef j
   @undef i
@ENDPROC
@skip handles diagonal block with offset kk
@BEGINPROC doDiBlockTkk n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define ir @dum@
   @define ii @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
         @iexp k @(i) @(mu) * @(j) +
@ROUT blk2C
         @iexp r @(i)
         @iexp c @(j)
         @iif j } i
         @iexp ir @(r) @(r) +
         @iexp ii @(ir) 1 +
      @callproc doElementT @(c) @(ir) @(ii) kk*@(nu)+@(k)
         @endiif
@ROUT C2blk
         @iif j < i
            @iexp r @(j)
            @iexp c @(i)
         @endiif
         @iif j } i
            @iexp r @(i)
            @iexp c @(j)
         @endiif
         @iexp ir @(r) @(r) +
         @iexp ii @(ir) 1 +
      @callproc doElementT @(c) @(ir) @(ii) kk*@(nu)+@(k)
@ROUT blk2C C2blk
         @iexp i @(i) 1 +
      @endiwhile
      @iif n_ = mu
            @iexp i @(mu) @(mu) +
            C@(j) += @(i);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef ii
   @undef ir
   @undef k
   @undef j
   @undef i
@ENDPROC
@skip  hanldes diagonal cleanup when mu=ma*nu
@SKIP IN: mu, nu, beta, alpha,
@BEGINPROC doCuDiBlockT m_ n_ ma_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define sc @dum@
   @define t @dum@
   @define ir @dum@
   @define ii @dum@
   @iexp sc 0
   @iwhile sc < @(ma_)
      case @(sc):
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
         @iexp k @(i) @(m_) *
         @iexp t @(sc) @(n_) *
         @iexp k @(k) @(t) +
         @iexp k @(k) @(j) +
         @iif j } i
            @iexp ir @(i) @(i) +
            @iexp ii @(ir) 1 +
            @callproc doElementT @(j) @(ir) @(ii) @(k)
         @endiif
         @iexp i @(i) 1 +
      @endiwhile
      @iexp i @(n_) @(n_) +
         C@(j) += @(i);
      @iexp j @(j) 1 +
   @endiwhile
         break;
      @iexp sc @(sc) 1 +
   @endiwhile
   @undef ii
   @undef ir
   @undef t
   @undef sc
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP handles partial block when nu=na*mu 
@BEGINPROC doDiBlockTna m_ n_ mu_ nu_ inc_ sc_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define t @dum@
   @define ir @dum@
   @define ii @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp t @(nu_) @(sc_) *
         @iexp t @(t) @(j) +
         @iexp k @(i) @(mu_) * @(j) +
@ROUT C2blk
         @iif i > @(t)
         pr[@(k)] = 0.0;
         pi[@(k)] = 0.0;
         @endiif
@ROUT C2blk blk2C
         @iif i { @(t)
            @iexp t @(sc_) 1 +
            @iexp t @(t) @(nu_) *
            @iif i < @(t)
               @iexp ir @(i) @(i) +
               @iexp ii @(ir) 1 +
         @callproc doElementT @(j) @(ir) @(ii) @(k)  
            @endiif   
         @endiif
         @iexp i @(i) 1 +
      @endiwhile
         @iexp i @(inc_) @(inc_) +
            C@(j) += @(i);
      @iexp j @(j) 1 +
   @endiwhile
   @undef ii
   @undef ir
   @undef t
   @undef k
   @undef j
   @undef i
@ENDPROC
@ROUT C2blk `#if 0`
#ifndef Mjoin
   #define Mjoin(pre, nam) my_join(pre, nam)
   #define my_join(pre, nam) pre ## nam
#endif
/*
 * The block is assumed to store L, this function does a transpose while
 * copying so that it is transferred with Upper portion of C
 */
#ifdef Conj_
void Mjoin(ATL_USERCPMM,_L2UH)
#else
void Mjoin(ATL_USERCPMM,_L2UT)
#endif
(
   const size_t M,      /* number of rows in A */
   const size_t N,      /* number of columns in A */
   const @(typ) *alpha, /* scalar for b */
   @ROUT blk2C
   const @(typ) *rC,    /* real block stored in @(mu)x@(nu)-major order */
   const @(typ) *iC,    /* imag block stored in @(mu)x@(nu)-major order */
   const @(typ) *beta,  /* scalar for C */
   @(typ) *C,           /* matrix to be copied to access-major format */
   const size_t ldc     /* stride between row elements */
   @ROUT C2blk
   const @(typ) *C,     /* matrix to be copied to access-major format */
   const size_t ldc,    /* stride between row elements */
   const @(typ) *beta,  /* scalar for C */
   @(typ) *rC,          /* real block stored in @(mu)x@(nu)-major order */
   @(typ) *iC           /* imag block stored in @(mu)x@(nu)-major order */
   @ROUT C2blk blk2C
)
{
   const unsigned int mf = M/@(mu), nf = N/@(nu);
   const unsigned int m = mf*@(mu), n = nf*@(nu), mr = M-m, nr = N-n;
   unsigned int i, j;
   @iif alpX ! 0
   const register @(typ) ra=(*alpha), ia=alpha[1];
   @endiif
   @iif betX ! 0
   const register @(typ) rb=(*beta), ib=beta[1];
   @endiif
@iif na = 1      
   const size_t ldc2 = ldc+ldc, incC0 = ldc2*@(nu);
@ROUT blk2C `   @declare "   @(typ) " n n ";"`
@ROUT C2blk `   @declare "   const @(typ) " n n ";"`
      *C0=C
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc2
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
@endiif
@iif na ! 1      
   const size_t ldc2 = ldc+ldc, incC0 = ldc2*@(mu);
@ROUT blk2C `   @declare "   @(typ) " n n ";"`
@ROUT C2blk `   @declare "   const @(typ) " n n ";"`
      *C0=C
      @define j @1@
      @iwhile j < @(mu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc2
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
@endiif
@iif mEn = 0
   @iif ma ! 1
   unsigned int pansz = @(ma)*@(bs);
@ROUT blk2C `   const @(typ) *pr = rC, *pi = iC;` 
@ROUT C2blk `   @(typ) *pr = rC, *pi = iC;` 
   int kk;
   @endiif
@endiif
@iif na = 1
   for (j=0; j < nf; j++)
   {
      unsigned int incC = incC0 - ((j+1)<<1)*@(nu);
      @iif mEn = 0
         @iif ma ! 1
      rC = pr; iC = pi;
      kk = j % @(ma);
         @endiif
      @endiif
      for (i=0; i < j; i++, rC += @(bs), iC += @(bs))
      {
      @iif mEn = 1
         @callproc doBlockT @(mu) @(nu)
      @endiif
      @iif mEn = 0
         @iif ma ! 0
         @callproc doBlockTkk @(nu) @(nu) 
         @endiif
      @endiif
      }
   @iif mEn = 1
      @callproc doDiBlockT @(nu)
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
      rC += @(bs); iC += @(bs); 
   @endiif
   @iif mEn = 0
      @iif ma ! 1
      switch(j%@(ma))
      {
      @callproc doCuDiBlockT @(mu) @(nu) @(ma)
      default:;
      }
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
      pr += ((j+1)%@(ma)==0? pansz: 0);
      pi += ((j+1)%@(ma)==0? pansz: 0);
      pansz += ((j+1)%@(ma)==0? @(ma)*@(bs):0);
      @endiif
   @endiif
   }
@endiif
@iif na ! 1
   for (j=0; j < mf; j++)
   {
      size_t incC = incC0 - ((j/@(na)+1)*@(nu))>>1;
      for (i=0; i < j/@(na); i++, rC+=@(bs), iC+=@(bs))
      {
         @callproc doBlockTna @(nu) @(mu) @(mu) @(nu)
      }
      switch(j%@(na))
      {
      @iexp n 0
      @iwhile n < @(na)
      case @(n):
         @callproc doDiBlockTna @(nu) @(mu) @(mu) @(mu) @(nu) @(n)
      break;
         @iexp n @(n) 1 +
      @endiwhile
      default:;
      }
   @iexp j 0
   @iwhile j < @(mu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
      rC += @(bs); iC += @(bs);
   }
@endiif
@iif nu > 1
   @iif mEn = 1
   switch(nr)
   {
   @iexp n 1
   @iwhile n < @(nu)
   case @(n):
      for (i=0; i < mf; i++, rC += @(bs), iC += @(bs))
      {
         @callproc doBlockT @(mu) @(n)
      }
      switch(mr)
      {
   @iexp m 1
   @iwhile m < @(mu)
      case @(m):
      @skip Assumption for sryk  m = n" 
      @callproc doDiBlockT @(m) 
      @iexp m @(m) 1 +
         break;
   @endiwhile
      default:;
      }
      break;
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
   @endiif
   @iif mEn = 0
      @iif ma ! 1
      rC = pr; iC = pi;
      kk = nf % @(ma);
      switch(nr)
      {
         @iexp n 1
         @iwhile n < @(nu)
         case @(n) :
            for (i=0; i < nf; i++, rC+=@(bs), iC+=@(bs))
            {
               @callproc doBlockTkk @(nu) @(n)
            }
               @callproc doDiBlockTkk @(n)
         break;
            @iexp n @(n) 1 +
         @endiwhile
      default:;
      }
      @endiif
   @endiif
@endiif
@iif mu > 1
   @iif na ! 1
   switch (mr)
   {
      @iexp n 1
      @iwhile n < @(mu)
      case @(n):
         for (i=0; i < nf; i++, rC+=@(bs), iC+=@(bs))
         {
         @callproc doBlockTna @(nu) @(n) @(mu) @(nu)
         }
         switch ( mf % @(na))
         {
            @iexp m 0 
            @iwhile m < na  
         case @(m):
            @callproc doDiBlockTna @(nu) @(n) @(mu) @(mu) @(nu) @(m)
            break;
               @iexp m @(m) 1  +
            @endiwhile
         }
      break;
         @iexp n @(n) 1 +
      @endiwhile
   default:;
   }
   @endiif
@endiif
}
@ROUT C2blk `#endif`
@endiif
@SKIP ***************** END of SYRK L2UT: complex type**************************
@ROUT blk2C_x87
@BEGINPROC GetAOff i_ j_
   @define of @1@
@iif @iexp @(i_) 0 = @(j_) 0 = &
   @define ao @(pA)@
@endiif
@iif @(j_) = 0
   @define al @@(i_)*SZ(pA)@
@endiif
@iif @(j_) = 1
   @iif (i_) = 0
      @define al @(pA,lda)@
   @endiif
   @iif (i_) ! 0
      @define al @@(i_)*SZ(pA,lda)@
   @endiif
@endiif
@iif @(j_) = 2
   @iif (i_) = 0
      @define al @(pA,lda,2)@
   @endiif
   @iif (i_) ! 0
      @define al @@(i_)*SZ(pA,lda,2)@
   @endiif
@endiif
@iif @(j_) = 3
   @iif (i_) = 0
      @define al @(pA,lda3)@
   @endiif
   @iif (i_) ! 0
      @define al @@(i_)*SZ(pA,lda3)@
   @endiif
@endiif
@iif @(j_) = 4
   @iif (i_) = 0
      @define al @(pA,lda,4)@
   @endiif
   @iif (i_) ! 0
      @define al @@(i_)*SZ(pA,lda,4)@
   @endiif
@endiif
@ENDPROC
#include "atlas_asm.h"
/*
 *                            rdi       rsi             xmm0            rdx
 * void ATL_ATL_USERCPMM(size_t M, size_t N, const TYPE alpha, const TYPE *w,
 *                                  xmm1       rcx         r8
 *                       const TYPE beta, TYPE *A, size_t lda);
 *                       
 */
#define M    %rdi
#deifne N    %rsi
#define pW   %rdx
#define pA   %rcx
#define lda  %rax  /* comes in r8 */
#define lda3 %r8  
#define Mr   %r9
#define Nr   %r10
#define II   %r11
.text
.global ATL_asmdecor(ATL_USERCPMM)
ALIGN16
ATL_asmdecor(ATL_USERCPMM):
   mov M, Mr
/*
 * M = M / 12  -> (M/4) /3;
 */
   shr $2, M   /* M /= 4 */
   mov M, %rax
   movabsq $-6148914691236517205, M
   mulq M
   shrq M
/*
 * rax = 12*(M/12)
 */
   lea (M,M,2), %rax /* rax = 3*(M/12) */
   shl $2, %rax      /* rax = 12*(M/12) */
   sub %rax, Mr      /* Mr = M - (M/12)*12 */

   shr $2, N  /* N /= 4 */
   mov N, %rax
   shl $2, %rax
   sub %rax, Nr     /* Nr = N - (N/4)*4 */

   mov %r8, lda
   lea (%r8,%r8,2), lda3
   #ifdef ALPHAX
      movlpd %xmm0, -8(%rsp)
      fldl -8(%esp)              /* ST={alpha} */
      #ifdef BETAX
         movlpd %xmm1, -8(%rsp)
         fldl -8(%esp)           /* ST={beta,alpha} */
         #define SCAN 2
      #else
         #define SCAN 1
      #endif
   #elif defined(BETAX)
      #define SCAN 1
      movlpd %xmm1, -8(%rsp)
      fldl -8(%esp)              /* ST={beta} */
   #else
      #define SCAN 0
   #endif
   #if SCAN == 1
      #define ST4 %st4
      #define ST5 %st5
      #define ST6 %st6
   #elif SCAN == 2
      #define ST4 %st5
      #define ST5 %st6
      #define ST6 %st7
   #endif
   cmp $0, N
   je CLEAN_N
   cmp $0, M
   je CLEAN_N
   LOOPN:
      mov M, II
      LOOPM:
         fldl (pW)          /* ST={p[0],[bet],[alp]} */
         #ifdef BETAX
            fmul %st1, %st  /* ST={bet*p[0],[bet],[alp]} */
         #elif defined(BETAN) || defined(BETAN1)
            fchs
         #endif
         fldl 8(pW)         /* ST={p[1], bet*p[0],[bet],[alp]} */
         #ifdef BETAX
            fmul %st2, %st  /* ST={bet*p[1],bet*p[0],[bet],[alp]} */
         #elif defined(BETAN) || defined(BETAN1)
            fchs
         #endif
         fldl 16(pW)        /* ST={p[2], bet*p[1],bet*p[0],[bet],[alp]} */
         #ifdef BETAX
            fmul %st3, %st  /* ST={bet*p[2],bet*p[1],bet*p[0],[bet],[alp]} */
         #elif defined(BETAN) || defined(BETAN1)
            fchs
         #endif
         fldl (pA)  /* ST={A[0],{bet*p[2],bet*p[1],bet*p[0],[bet],[alp]} */
         #ifdef ALPHAX
            fmul ST4, %st
         #elif defined(BETAN) || defined(BETAN1)
            fchs
         #endif
         fldl 8(pA)
         #ifdef ALPHAX
            fmul ST5, %st
         #elif defined(ALPHAN) || defined(ALPHAN1)
            fchs
         #endif
         fldl 16(pA)
         #ifdef ALPHAX
            fmul ST6, %st /*{A[2],A[1],A[0],p[2],p[1],p[0],[bet],[alp] */
         #elif defined(ALPHAN) || defined(ALPHAN1)
            fchs
         #endif
         dec II
      jne LOOPM
      dec N
   jne LOOPN

